<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>kmp算法</title>
      <link href="/2020/09/29/kmp-suan-fa/"/>
      <url>/2020/09/29/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><blockquote><p>照着算法导论写了kmp算法</p></blockquote><pre><code class="python">def KMP(T, P):    &quot;&quot;&quot;    :param T:    :param P: 待匹配字符串    :return:    &quot;&quot;&quot;    n = len(T)    m = len(P)    k = 0    fail = get_fail(P)    for i in range(n):        while k &gt; 0 and T[i] != P[k]:            k = fail[k - 1]        if T[i] == P[k]:            k += 1        if k == m:            return True    return Falsedef get_fail(P):    n = len(P)    fail = [0] * n    k = 0    for j in range(1, n):        while k &gt; 0 and P[j] != P[k]:            k = fail[k - 1]        if P[j] == P[k]:            k = k + 1        fail[j] = k    return fail</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> kmp,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2020/09/11/kuai-su-pai-xu/"/>
      <url>/2020/09/11/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<!--之前其实也实现过快速排序也能理解快速排序的原理但其实实现的不是很熟练边界难以掌握希望这一次能够完全弄明白--><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>根据算法导论,实现如下</p><pre><code>def quicksort(nums, l, r):    if l &lt; r:        q = partition(nums, l, r)        quicksort(nums, l, q - 1)        quicksort(nums, q + 1, r)def partition(nums, l, r):    x = nums[r]    i = l - 1    for j in range(l, r):        if nums[j] &lt;= x:            i = i + 1            nums[i], nums[j] = nums[j], nums[i]    nums[i + 1], nums[r] = nums[r], nums[i + 1]    return i + 1</code></pre><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><h4 id="quicksort"><a href="#quicksort" class="headerlink" title="quicksort"></a>quicksort</h4><p>没什么好说的,就是普通的二分处理</p><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>选定一元素,默认为最右侧元素</p><p>维护一个比选定元素小的子数组</p><p>这个子数组从0开始</p><p>每遇到比选定元素小于等于的元素使子数组扩张1个</p><p>并交换选定位置</p><p>最后交换选定元素到指定位置</p><h3 id="随机化版本"><a href="#随机化版本" class="headerlink" title="随机化版本"></a>随机化版本</h3><!--卧槽这就是大师吗?讲道理这里真的牛逼--><pre><code class="python">def random_partition(nums, l, r):    i = random.randint(l, r)    nums[i], nums[r] = nums[r], nums[i]    return partition(nums, l, r)def random_quicksort(nums, l, r):    if l &lt; r:        q = random_partition(nums, l, r)        random_quicksort(nums, l, q - 1)        random_quicksort(nums, q + 1, r)</code></pre><h3 id="迭代版本"><a href="#迭代版本" class="headerlink" title="迭代版本"></a>迭代版本</h3><pre><code class="python">def quicksort(nums, l, r):    st = [(l, r)]    while len(st) &gt; 0:        top = st.pop()        left, right = top[0], top[1]        if left &lt; right:            i = partition(nums, left, right)            st.append((left, i - 1))            st.append((i + 1, right))def partition(nums, l, r):    x = nums[r]    i = l - 1    for j in range(l, r):        if nums[j] &lt;= x:            i += 1            nums[i], nums[j] = nums[j], nums[i]    nums[i + 1], nums[r] = nums[r], nums[i + 1]    return i + 1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 快速排序,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java锁探究</title>
      <link href="/2020/09/05/java-suo-tan-jiu/"/>
      <url>/2020/09/05/java-suo-tan-jiu/</url>
      
        <content type="html"><![CDATA[<!--面试官问我你都知道哪些锁原理都是什么?我回cas失败了怎么办?我不会了.......--><h2 id="从lock接口说起"><a href="#从lock接口说起" class="headerlink" title="从lock接口说起"></a>从lock接口说起</h2><ol><li><p>lock</p><p>获取锁</p></li><li><p>trylock</p><p>尝试获取锁,如果有时间参数,应当是在该时间内阻塞住</p></li><li><p>unlock</p><p>释放锁</p></li><li><p>newCondition</p><p>不理解</p></li></ol><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ol><li><p>公平锁和非公平锁</p><p>默认为非公平锁</p></li><li><p>实际上是类里的sync的不同实现</p><p>而类里的sync实际上是抽象类aqs的实现</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java,面试,锁,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java容器分析</title>
      <link href="/2020/09/02/javahashmap-fen-xi/"/>
      <url>/2020/09/02/javahashmap-fen-xi/</url>
      
        <content type="html"><![CDATA[<!--面试管问我 hashmap 什么时候扩容 ?用什么数据结构?并让我手写put方法我写了个链表的但是后来想想,发现我存是存进去了,怎么取出来呢?或者说我怎么确定我取出来的是我存进去的呢?--><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>用来存储信息的节点,存有键和值,hash也存?</p><p>这个的hashcode是键和值的异或?</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>主要是处理了初始容量和加载因子的边界值</p><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>调用putval方法,是putval方法的固定参数版</p><h3 id="putval"><a href="#putval" class="headerlink" title="putval"></a>putval</h3><p>判断table==null或者tab的大小==0</p><p>触发resize()方法</p><p>首先位置上如果==null直接插入即可</p><p>而若是位置上有节点且key相同</p><p>则获得到该节点</p><p>若对应节点p继承自TreeNode,表明该节点上已成红黑树,putTreeval</p><p>否则 遍历到最后一个节点,插入并检查是否到达树化时机,树化</p><p>若遍历到中间,发现该节点已存在,则跳出循环</p><p>判断e是否为null</p><p>如果此时e不为null,说明在map中已经存在了相同的key</p><p>如果真的插入了元素的话</p><p>需要判断扩容</p><h3 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h3><p>返回node&lt;k,v&gt;的数组</p><p>这个数组容量貌似总是2的幂</p><p>对新的容量和再次扩容的时机进行计算</p><p>申请一个更大的数组,</p><p>如果旧数组中有元素,</p><p>将每个元素复制到新数组中</p><p>其中元素的位置用&amp;(大小-1)计算,好像比余数快?</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当数组大小为0时,会共享一个空数组实例</p><p>否则会分配一个对应大小的数组</p><p>为负数时会报错</p><h3 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h3><p>在最后加就是O(1)</p><p>在中间加就是O(n)</p><p>到达指定size就会扩容</p><p>每次扩容一半然后进行检查</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>为空或者构造链表</p><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><p>判断是不是最后一个,是直接插入</p><p>不是的话调用node方法</p><p>在这个节点的位置上插入</p><h3 id="node-index"><a href="#node-index" class="headerlink" title="node(index)"></a>node(index)</h3><p>判断在前半部分还是后半部分</p><p>以位置和大小为依据</p><p>返回这个位置上的节点</p>]]></content>
      
      
      
        <tags>
            
            <tag> java,集合,hashmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我印象中的http协议</title>
      <link href="/2020/09/02/wo-yin-xiang-zhong-de-http-xie-yi/"/>
      <url>/2020/09/02/wo-yin-xiang-zhong-de-http-xie-yi/</url>
      
        <content type="html"><![CDATA[<!--面试官问我 http链接能复用吗?我被这道题蒙到了,其实我看过长连接短链接的问题而且就算当时忘了也可以从下往上想所谓http链接不就是在tcp上发个报文过去服务器接收到消息再返回吗如果建立的tcp链接是一个怎么就不能复用了--><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>所以,到现在我脑海中的http协议是这样的:</p><ol><li>建立tcp连接</li><li>由客户端首先发起请求,格式固定</li><li>服务端接收到请求后,返回响应</li></ol><p>至于双方请求细节,由头部确定</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>在请求中cookie:key1=value1;</p><p>在响应中set-cookie: key:value;</p><p>在响应中的cookie只能一条一条设置,分号后面是设置这个cookie的作用于之类的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试,计算机网络,http,抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统</title>
      <link href="/2020/08/29/shen-ru-li-jie-ji-suan-ji-xi-tong/"/>
      <url>/2020/08/29/shen-ru-li-jie-ji-suan-ji-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>整数</p><ul><li>原码:首位符号位,其余正常的二进制</li><li>反码:首位为负值,并且需要+1,其余为正常值</li><li>补码:首位为负值,其余位为正常值</li></ul></li><li><p>浮点数</p><p>首位符号位,阶码,尾数</p><ul><li><p>阶码</p><p>我以为,阶码可以理解为有例外情况的反码</p><p>当全为0时特殊处理</p><p>例如 0001 可以理解为 1110 即 -6</p></li></ul><p>例: 0 0000 0001</p><p>首位为0 ,正数</p><p>阶码位置字面表示为0 E=1-(2^(4-1)-1)=-6 权重为2^(-6)=1/64</p><p>尾数为1/16</p><p>结果为 1/64*1/16</p><p>0 0001 0001</p><p>首位为0 ,正数</p><p>阶码位置字面表示为1 E=1-(2^(4-1)-1)=-6 权重为2^(-6)=1/64</p><p>尾数为17/16</p><p>结果为 1/64*17/16</p></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>溢出都会保留低位作为新值</p><p>强制转换不改变位,只改变解释位的方法 </p><h4 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h4><p>对于一个整数</p><p>大端: 将高位存在低地址</p><p>小端: 将低位存在低地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机系统,读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马拉车算法</title>
      <link href="/2020/08/29/ma-la-che-suan-fa/"/>
      <url>/2020/08/29/ma-la-che-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><blockquote><p>刷leetcode时,遇到了<a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">这道题</a></p></blockquote><p>粗一分析,发现本质上是在找这个字符串的最长回文前缀,将非前缀的转置加到前面就是结果了</p><h3 id="超时代码"><a href="#超时代码" class="headerlink" title="超时代码"></a>超时代码</h3><pre><code class="python">class Solution:    def checkP(self, s: str):        for i in range(int(len(s) / 2)):            if s[i] != s[len(s) - 1 - i]:                return False        return True    def shortestPalindrome(self, s: str) -&gt; str:        if self.checkP(s):            return s        # t = &#39;&#39;        # for i in range(len(s))[::-1]:        #     t = t + s[i]        #     p = t + s        #     if self.checkP(p):        #         return p        n=len(s)        max_num=0        for i in range(2,n):            if self.checkP(s[:i]):                max_num=max(max_num,i)        if max_num==0:            return s[1:][::-1]+s        return s[max_num:][::-1]+s</code></pre><p>每个中心遍历一遍,重复判断回文</p><p>时间复杂度O(n^2)</p><h3 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h3><pre><code class="python">class Solution:    def checkP(self, s: str):        for i in range(int(len(s) / 2)):            if s[i] != s[len(s) - 1 - i]:                return False        return True    def shortestPalindrome(self, s: str) -&gt; str:        def manacher(s1: str):            s1 = &quot;#&quot; + &quot;#&quot;.join(s1) + &quot;#&quot;            n = len(s1)            p = [0] * n            center, max_right = 0, 0            for i in range(n):                length = 0                if i &lt; max_right:                    length = min(p[center * 2 - i], max_right - i)                while i - length &gt;= 0 and i + length &lt; n and s1[i + length] == s1[i - length]:                    if length + i &gt; max_right:                        max_right = length + i                        center = i                    length += 1                p[i] = length - 1            return p        if self.checkP(s):            return s        n = len(s)        p = manacher(s)        max_num = 0        for i in range(len(p)):            if i - p[i] == 0:                max_num = max(max_num, (i + p[i])//2)        if max_num == 0:            return s[1:][::-1] + s        return s[max_num:][::-1] + s</code></pre><p>时间复杂度O(n)</p><p>参考了<a href="https://www.cxyxiaowu.com/2665.html" target="_blank" rel="noopener">这篇文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法,回文字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次pdf去水印的流程</title>
      <link href="/2020/08/20/pdf-qu-shui-yin/"/>
      <url>/2020/08/20/pdf-qu-shui-yin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在网上找到了一份学习资料,但是上面的水印十分影响阅读,我想把水印去掉</p></blockquote><ol><li><p>首先想到的就是python有没有什么库可以操作pdf</p><blockquote><p>经过搜索发现有人用pypdf2去水印,并且贴上了代码:<a href="https://www.jianshu.com/p/f449a6e86602" target="_blank" rel="noopener">链接</a></p><p>试着运行了下这份代码,没有解决我的问题</p></blockquote></li><li><p>在查看了pypdf2官方文档,debug无果之后,尝试打印了第一页所有的格式,发现只有如下几种:</p><blockquote><p>[b’q’, b’BT’, b’Tf’, b’Tc’, b’Tm’, b’g’, b’G’, b’TJ’, b’ET’, b’Q’, b’Tr’, b’w’, b’cm’, b’re’, b’f*’, b’BDC’, b’gs’, b’Do’, b’EMC’]</p></blockquote></li><li><p>尝试依次去除一种格式,观察效果:</p><blockquote><pre><code>Tm 格式全去掉为空Tf 格式去掉为乱码g 格式全去掉出现小黑快cm 格式去掉水印出现倾斜gs 格式去掉水印变黑了Do 格式去掉水印消失了</code></pre></blockquote></li><li><p>所以说,只要把每一页的Do格式的文本替换为空,就可以达到去水印的目的</p></li><li><p>但是我觉着到目前为止的东西都太体力了,我想要一种快捷的做法</p></li><li><p>又去网上找到了一篇介绍pdf文件格式的文章, <a href="https://lazymind.me/2017/10/pdf-structure/" target="_blank" rel="noopener">链接</a></p></li><li><p>在程序中打印了格式为Do的数据,输出如下</p><blockquote><p>[‘/KSPX1’]</p></blockquote></li><li><p>用文本编辑器打开pdf文件并搜索,得到这样的内容</p><p><img src="img.jpg" alt=""></p></li><li><p>将<code>&lt;&lt;/KSPX1 5548 0 R &gt;&gt;</code>删除可以删除一页的水印</p></li><li><p>而由前面的文章可以知道,这个是一个间接引用,将关键字改为5548 0 obj可以搜索到</p><p><img src="img2.jpg" alt=""></p></li><li><p>将这一段删掉即可去除整个pdf的水印</p></li></ol><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ol><li>如果一页的水印只有一个的话,可以尝试计算出对应格式出现的次数,优先删除出现次数为1的格式</li><li>到现在也不明白所谓的格式是什么</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> pdf,小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用js使一个表单跳转到不同页面</title>
      <link href="/2020/06/03/yong-js-shi-yi-ge-biao-dan-tiao-zhuan-dao-bu-tong-ye-mian/"/>
      <url>/2020/06/03/yong-js-shi-yi-ge-biao-dan-tiao-zhuan-dao-bu-tong-ye-mian/</url>
      
        <content type="html"><![CDATA[<ol><li><p>设置不同的button</p></li><li><p>为每个button设置onclick事件</p></li><li><p>事件内容如下:</p><pre><code class="javascript">function 方法名() {     document.你的表单名.action=&quot;要跳转到的url&quot;     document.你的表单名.submit()}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像加速配置</title>
      <link href="/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/"/>
      <url>/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/</url>
      
        <content type="html"><![CDATA[<pre><code class="json">{  &quot;registry-mirrors&quot;: [    &quot;https://hub-mirror.c.163.com/&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;https://reg-mirror.qiniu.com&quot;,    &quot;https://mirror.ccs.tencentyun.com&quot;  ],  &quot;insecure-registries&quot;: [],  &quot;debug&quot;: true,  &quot;experimental&quot;: false}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker,环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程</title>
      <link href="/2020/05/25/python-duo-xian-cheng/"/>
      <url>/2020/05/25/python-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每次用到python多线程,都是看了就忘</p></blockquote><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>用法:<code>threading.Thread(target=函数名)</code>创建线程,<code>start</code>开始执行,<code>join</code>等待完成</p><p>示例:</p><pre><code class="python">import threadingreader_count = 0write_count = 0reader_amount = 0write_amount = 0def reader():    global reader_count, write_count, reader_amount, write_amount    while reader_amount &gt; 0:        if reader_count &gt; 0 or write_count == 0:            reader_count += 1            print(&#39;read&#39;)            reader_amount -= 1            reader_count -= 1        else:            print(&quot;can&#39;t read&quot;)def writer():    global reader_count, write_count, reader_amount, write_amount    while write_amount &gt; 0:        if reader_count &gt; 0 or write_count &gt; 0:            print(&quot;can&#39;t write&quot;)        else:            write_count += 1            print(&#39;write&#39;)            write_amount -= 1            write_count -= 1if __name__ == &#39;__main__&#39;:    reader_amount = int(input(&#39;读次数:&#39;))    write_amount = int(input(&#39;写次数:&#39;))    read = threading.Thread(target=reader)    write = threading.Thread(target=writer)    write.start()    read.start()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴百度网盘自动填写提取码脚本</title>
      <link href="/2020/05/25/you-hou-bai-du-wang-pan-zi-dong-tian-xie-ti-qu-ma-jiao-ben/"/>
      <url>/2020/05/25/you-hou-bai-du-wang-pan-zi-dong-tian-xie-ti-qu-ma-jiao-ben/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">// ==UserScript==// @name         百度网盘自动填写提取码// @namespace    http://tampermonkey.net/// @version      0.2// @description  try to take over the world!// @author       zhanzhi// @match        https://pan.baidu.com/*// @grant        none// ==/UserScript==(function() {    &#39;use strict&#39;;var body=document.getElementsByTagName(&#39;body&#39;)[0]var reg=/https?:\/\/pan.baidu.com\/s\/.{23}.*?提取码.*?([0-9a-zA-Z]{4})/svar link_reg=/^https?:\/\/pan.baidu.com\/s\/.(.{22})/var key_reg=/[0-9a-zA-Z]{4}$/var links_and_keys=body.innerHTML.match(reg)var links=[]var keys=[]if(location.href.match(/^https?:\/\/pan.baidu.com/)!==null){    var key=location.href.split(&#39;#&#39;)[1]    var key_input=document.getElementsByTagName(&#39;input&#39;)[0]    if(typeof key ===&quot;string&quot;)    {        key_input.value=key        var but=document.getElementsByClassName(&quot;g-button g-button-blue-large&quot;)[0]        but.click()    }}else{    var vm=body.innerHTML    links.push(links_and_keys[0].match(link_reg)[0])    keys.push(links_and_keys[1].match(key_reg)[0])    var surl=links_and_keys[0].match(link_reg)[1]    var url=&#39;https://pan.baidu.com/share/init?surl=&#39;+surl    vm=vm.replace(links_and_keys[0].match(link_reg)[0],url+&#39;#&#39;+links_and_keys[0].match(key_reg)[0])    body.innerHTML=vm}})();</code></pre><blockquote><p>经观察,虽然百度盘的分享链接会重定向</p><p>不过重定向的url都是有规律的</p><p>如分享链接为<a href="https://pan.baidu.com/s/1.{22}" target="_blank" rel="noopener">https://pan.baidu.com/s/1.{22}</a></p><p>那么填写提取码的链接就是<a href="https://pan.baidu.com/share/init?surl=加上上面.{22}匹配到的内容" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=加上上面.{22}匹配到的内容</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js,油猴脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕bp神经网络</title>
      <link href="/2020/05/24/zhi-neng-ji-suan/"/>
      <url>/2020/05/24/zhi-neng-ji-suan/</url>
      
        <content type="html"><![CDATA[<p>智能计算的作业,按照公式实现</p><pre><code class="python">import mathimport random# node 三维数组# 第一维表示层# 第二维表示节点# 第三维分别表示输出,到下一层节点的权值,最后一个表示sitadef BP_test(node):    print(&#39;输入数据&#39;)    num1 = int(input())    num2 = int(input())    node[0][0][0] = num1    node[0][1][0] = num2    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj    print(node[-1][0][0])def BP_once(node, y_train, s=0.6):    # 前向计算每个神经元的输出加权和sj和输出    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj            # print(node[layer_count][node_index][0])    y = []    t = y_train    for layer_count in range(1, len(node))[::-1]:        y = t        t = []        for node_index in range(len(node[layer_count])):            oj = node[layer_count][node_index][0]            ej = oj * (1 - oj)            if layer_count == len(node) - 1:                ej *= (y_train[node_index] - oj)                t.append(ej)            else:                we = 0                for i in range(len(node[layer_count + 1])):                    we += y[i] * node[layer_count][node_index][i + 1]                ej *= we            # 先更新sita            node[layer_count][node_index][-1] += s * ej            for i in range(len(node[layer_count - 1])):  # 更新上一层节点的权重                node[layer_count - 1][i][node_index + 1] += s * node[layer_count - 1][i][0] * ej    passdef BP_main(x_train, y_train, s=0.6, t=5000):    random.seed(1)    node = []    node.append([[1, 0.2, -0.3], [0, 0.4, 0.1]])    node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    node.append([[1, 0.1]])    for i in range(len(node)):        for j in range(len(node[i])):            for k in range(len(node[i][j])):                node[i][j][k] = random.random()    train_count = 0    for k in range(t):        for i in range(len(x_train)):  # 选中第几组训练数据            y = []            y.append(y_train[i])            for j in range(len(x_train[i])):                node[0][j][0] = x_train[i][j]            BP_once(node, y, s)    return nodeif __name__ == &#39;__main__&#39;:    # node = []    # node.append([[1, 0.2, -0.3], [0, 0.4, 0.1], [1, -0.5, 0.2]])    # node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    # node.append([[1, 0.1]])    # BP_once(node, [1])    node = BP_main([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 1, 1, 0])    print(&quot;训练结束&quot;)    while True:        BP_test(node)</code></pre><p><code>BP_once:</code>训练一次,可设置学习率</p><p><code>BP_main:</code>反复调用BP_once达到训练多次的目的,并且这里也定义了层数,节点数,和权值的初始化,这个函数有两个参数,第一个是一个二维数组,第一维表示不同的训练数据,第二维表示训练数据的不同值,第二个参数是包含不同训练数据的结果的数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五子棋AI</title>
      <link href="/2020/03/19/wu-zi-qi-ai/"/>
      <url>/2020/03/19/wu-zi-qi-ai/</url>
      
        <content type="html"><![CDATA[<h2 id="五子棋AI"><a href="#五子棋AI" class="headerlink" title="五子棋AI"></a>五子棋AI</h2><blockquote><p>大二时通过一本书学会了画五子棋的棋盘和棋子,于是写了个AI</p></blockquote><p><a href="https://zhanzhl.github.io/gobang/">效果演示</a></p><pre><code>var canvas =document.getElementById(&quot;canvas&quot;)        var ctx =canvas.getContext(&quot;2d&quot;)        var isblack=true        var arr=new Array()        var wei=new Array()        for(var i=0;i&lt;20;i++)//定义棋子局势        {            arr[i]=new Array();            for(var j=0;j&lt;20;j++)            {                arr[i][j]=0;            }        }        for(i=0;i&lt;20;i++)//设置棋子权重        {            wei[i]=new Array();            for(j=0;j&lt;20;j++)            {                wei[i][j]=20-Math.abs(i+j-20)            }        }        ctx.strokeStyle=&quot;#009688&quot;        ctx.beginPath();        for(i=0;i&lt;19;i++)        {            ctx.moveTo(10+i*20,10)            ctx.lineTo(10+i*20,370)            ctx.moveTo(10,10+20*i)            ctx.lineTo(370,10+i*20)        }        ctx.stroke()        $(&quot;#canvas&quot;).click(function(e){            if(!isblack)            {                alert(&quot;请稍后&quot;)                return            }            console.log(e.offsetX+&quot;,&quot;+e.offsetY)            var thisx=Math.round((e.offsetX-10)/20)            var thisy=Math.round((e.offsetY-10)/20)            if(luozi(thisx,thisy))                myAI()        })        function luozi(thisx,thisy)        {            if(arr[thisx][thisy]==0)            {                ctx.beginPath()                if(isblack)                {                    ctx.fillStyle=&quot;black&quot;                    arr[thisx][thisy]=1                }                else                {                    ctx.fillStyle=&quot;white&quot;                    arr[thisx][thisy]=2                }                ctx.arc(thisx*20+10,thisy*20+10,10,0,Math.PI*2,false)                ctx.fill()                ctx.stroke()                //(0,1)竖直方向胜利                //(1,0)水平方向胜利                //(1,1)从左上到右下                //(1,-1)从左下到右上                testVictory(0,1,thisx,thisy)                testVictory(1,0,thisx,thisy)                testVictory(1,1,thisx,thisy)                testVictory(1,-1,thisx,thisy)                updatewei(thisx,thisy)                isblack=!isblack                return true;            }            return false        }        function testVictory(x,y,newx,newy)        {            var max=1            var tx=newx            var ty=newy            var flag=arr[newx][newy]            while(arr[tx+x][ty+y]==flag)            {                tx=tx+x                ty=ty+y                max++            }            while(arr[newx-x][newy-y]==flag)            {                newx=newx-x                newy=newy-y                max++            }            if(max&gt;4)            {                flag==1?alert(&quot;黑方胜&quot;):alert(&quot;白方胜&quot;)                location.reload()            }        }        function updatewei(thisx,thisy)        {            var i=-4;            var j=-4;            if(thisx+i&lt;=0)                i=1-thisx;            if(thisy+j&lt;=0)                j=1-thisy;                var str=&quot;&quot;;            for(;i&lt;5;i++)            {                for(var j=-4;j&lt;5;j++)                {                    if(arr[thisx+i][thisy+j]==0)                    wei[thisx+i][thisy+j]=testWeight(thisx+i,thisy+j)                    str+=wei[thisx+i][thisy+j]+&quot;(&quot;+(thisx+i)+&quot;,&quot;+(thisy+j)+&quot;)&quot;+&quot;\t&quot;;                }                str+=&quot;\n&quot;            }            console.log(str);        }        function testWeight(thisx,thisy)        {            var weight=20-Math.abs(thisx+thisy-20);            weight+=tance(thisx,thisy,0,1,true)            weight+=tance(thisx,thisy,1,1,true)            weight+=tance(thisx,thisy,1,-1,true)            weight+=tance(thisx,thisy,1,0,true)            weight+=tance(thisx,thisy,0,1,false)            weight+=tance(thisx,thisy,1,1,false)            weight+=tance(thisx,thisy,1,-1,false)            weight+=tance(thisx,thisy,1,0,false)            return weight        }        function tance(newx,newy,x,y,black)        {            var count=0;            var tx=newx;            var ty=newy;            var flag=0;//当前棋子颜色            black?flag=1:flag=2;            var max=5;//探测半径            var mlen=0;//最大连续长度            var iscon=true;//是否连续            while(--max&amp;&amp;tx+x&gt;0&amp;&amp;ty+y&gt;0&amp;&amp;tx+x&lt;20&amp;&amp;ty+y&lt;20)            {                tx=tx+x;                ty=ty+y;                if(arr[tx][ty]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[tx][ty]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            max=5;            while(--max&amp;&amp;newx-x&gt;0&amp;&amp;newy-y&gt;0&amp;&amp;newx-x&lt;20&amp;&amp;newy-y&lt;20)            {                newx=newx-x;                newy=newy-y;                if(arr[newx][newy]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[newx][newy]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            if(mlen&gt;=4)                count=count*1000;            else if(mlen&gt;=3)                count=count*100;            else if(mlen&gt;=2)                count=count*10;            else                count=count;            if(count&lt;0)                count=0;            if(flag==2&amp;&amp;mlen==4)                count*=10;            return count        }        function myAI()//把上面那个写好了,这个函数只是一个遍历的事了        {            var x=1;            var y=1;            var weight=0            for(var i=0;i&lt;20;i++)            {                for(var j=0;j&lt;20;j++)                {                    if(weight&lt;wei[i][j]&amp;&amp;arr[i][j]==0)                    {                        weight=wei[i][j]                        x=i                        y=j                    }                }            }            console.log(&quot;我在&quot;+x+&quot; &quot;+y+&quot;下白子,权重是&quot;+wei[x][y]);            luozi(x,y);        }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python爬取m3u8视频</title>
      <link href="/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/"/>
      <url>/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/</url>
      
        <content type="html"><![CDATA[<h4 id="用python爬取m3u8视频"><a href="#用python爬取m3u8视频" class="headerlink" title="用python爬取m3u8视频"></a>用python爬取m3u8视频</h4><h4 id="m3u8格式"><a href="#m3u8格式" class="headerlink" title="m3u8格式"></a>m3u8格式</h4><p>m3u8是纯文本文档,里面包含了每个视频段的链接</p><p>合起来就是一个完整的视频,如下所示</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:7#EXT-X-MEDIA-SEQUENCE:0#EXTINF:4.712100,4ddf19cc057000000.ts#EXTINF:4.170000,4ddf19cc057000001.ts#EXTINF:4.170000,4ddf19cc057000002.ts</code></pre><p>应注意到<code>4ddf19cc057000000.ts</code>是第一个视频的链接,但是无法直接打开</p><p>因为这个链接是不完整的,需要在这个链接前加上完整的路径才是完整的链接</p><p>如:</p><p>你找到了一个m3u8文件,他的链接是<a href="http://localhost/path/m3u8/index.m3u8" target="_blank" rel="noopener">http://localhost/path/m3u8/index.m3u8</a></p><p>里面第一段视频链接是1.ts</p><p>那么这段视频的完整地址是<a href="http://localhost/path/m3u8/1.ts" target="_blank" rel="noopener">http://localhost/path/m3u8/1.ts</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>import requestsimport osfrom concurrent.futures import ThreadPoolExecutor, ALL_COMPLETEDm3u8_url = &#39;m3u8的链接&#39;  # m3u8的链接filename = &#39;22&#39;  # 下载后保存的名字max_worker = 8  # 线程数proxy = {&#39;http&#39;: &#39;http://127.0.0.1:1080&#39;, &#39;https&#39;: &#39;http://127.0.0.1:1080&#39;}  # 代理设置path = &quot;下载到哪个路径&quot;  # 下载到哪个路径def download_file(url, filename):    r = requests.get(url, proxies=proxy)    while r.status_code != 200:        r = requests.get(url, proxies=proxy)        print(filename,&#39;请求超时&#39;)    with open(filename, &quot;wb+&quot;) as f:        f.write(r.content)def parse():    pool = ThreadPoolExecutor(max_worker)    r = requests.get(m3u8_url, timeout=5, proxies=proxy)    base_url = os.path.dirname(m3u8_url)    temp = path + &quot;temp&quot; + os.path.sep    if not os.path.exists(temp):        os.makedirs(temp)    i = 0    for line in r.text.split(&#39;\n&#39;):        if line.find(&quot;.ts&quot;) != -1:            if not line.startswith(&quot;http&quot;):                line = base_url + &#39;/&#39; + line            pool.submit(download_file, line, temp + str(i).zfill(8) + &quot;.ts&quot;)            i = i + 1    pool.shutdown(wait=True)    os.system(&quot;cd {} &amp;&amp;copy /b *.ts ..\\{}&quot;.format(path + &quot;temp//&quot;,filename))    os.system(&quot;cd {} &amp;&amp;rmdir /s/q .\\temp&quot;.format(path))if __name__ == &#39;__main__&#39;:    parse()</code></pre><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><blockquote><p> requests不支持多线程,所以在多线程的情况下会有很多分片下载不全或者干脆没下载到</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python,爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium入门</title>
      <link href="/2020/02/27/selenium-ru-men/"/>
      <url>/2020/02/27/selenium-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="selenium入门"><a href="#selenium入门" class="headerlink" title="selenium入门"></a>selenium入门</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code class="shell">pip install selenium</code></pre><h4 id="windows配置"><a href="#windows配置" class="headerlink" title="windows配置"></a>windows配置</h4><ol><li>下载浏览器对应的webDriver</li><li>将解压后的程序添加到环境变量中</li><li>重启电脑</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用说明</title>
      <link href="/2020/02/26/hexo-shi-yong-shuo-ming/"/>
      <url>/2020/02/26/hexo-shi-yong-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h4 id="hexo常用操作"><a href="#hexo常用操作" class="headerlink" title="hexo常用操作"></a>hexo常用操作</h4><ol><li><p>新建文章<code>hexo new 文章标题</code></p></li><li><p>生成静态页面<code>hexo g</code></p></li><li><p>运行本地服务器<code>hexo s</code></p></li><li><p>提交到服务器<code>hexo d</code></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
