<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用js使一个表单跳转到不同页面</title>
      <link href="/2020/06/03/yong-js-shi-yi-ge-biao-dan-tiao-zhuan-dao-bu-tong-ye-mian/"/>
      <url>/2020/06/03/yong-js-shi-yi-ge-biao-dan-tiao-zhuan-dao-bu-tong-ye-mian/</url>
      
        <content type="html"><![CDATA[<ol><li><p>设置不同的button</p></li><li><p>为每个button设置onclick事件</p></li><li><p>事件内容如下:</p><pre><code class="javascript">function 方法名() {     document.你的表单名.action=&quot;要跳转到的url&quot;     document.你的表单名.submit()}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像加速配置</title>
      <link href="/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/"/>
      <url>/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/</url>
      
        <content type="html"><![CDATA[<pre><code class="json">{  &quot;registry-mirrors&quot;: [    &quot;https://hub-mirror.c.163.com/&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;https://reg-mirror.qiniu.com&quot;,    &quot;https://mirror.ccs.tencentyun.com&quot;  ],  &quot;insecure-registries&quot;: [],  &quot;debug&quot;: true,  &quot;experimental&quot;: false}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker,环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程</title>
      <link href="/2020/05/25/python-duo-xian-cheng/"/>
      <url>/2020/05/25/python-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每次用到python多线程,都是看了就忘</p></blockquote><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>用法:<code>threading.Thread(target=函数名)</code>创建线程,<code>start</code>开始执行,<code>join</code>等待完成</p><p>示例:</p><pre><code class="python">import threadingreader_count = 0write_count = 0reader_amount = 0write_amount = 0def reader():    global reader_count, write_count, reader_amount, write_amount    while reader_amount &gt; 0:        if reader_count &gt; 0 or write_count == 0:            reader_count += 1            print(&#39;read&#39;)            reader_amount -= 1            reader_count -= 1        else:            print(&quot;can&#39;t read&quot;)def writer():    global reader_count, write_count, reader_amount, write_amount    while write_amount &gt; 0:        if reader_count &gt; 0 or write_count &gt; 0:            print(&quot;can&#39;t write&quot;)        else:            write_count += 1            print(&#39;write&#39;)            write_amount -= 1            write_count -= 1if __name__ == &#39;__main__&#39;:    reader_amount = int(input(&#39;读次数:&#39;))    write_amount = int(input(&#39;写次数:&#39;))    read = threading.Thread(target=reader)    write = threading.Thread(target=writer)    write.start()    read.start()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>油猴百度网盘自动填写提取码脚本</title>
      <link href="/2020/05/25/you-hou-bai-du-wang-pan-zi-dong-tian-xie-ti-qu-ma-jiao-ben/"/>
      <url>/2020/05/25/you-hou-bai-du-wang-pan-zi-dong-tian-xie-ti-qu-ma-jiao-ben/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">// ==UserScript==// @name         百度网盘自动填写提取码// @namespace    http://tampermonkey.net/// @version      0.1// @description  try to take over the world!// @author       zhanzhi// @match        https://pan.baidu.com/*// @grant        none// ==/UserScript==(function() {    &#39;use strict&#39;;var body=document.getElementsByTagName(&#39;body&#39;)[0]var reg=/https?:\/\/pan.baidu.com\/s\/.{23}.*?提取码.*?([0-9a-zA-Z]{4})/igmvar link_reg=/^https?:\/\/pan.baidu.com\/s\/.{23}/var key_reg=/[0-9a-zA-Z]{4}$/var links_and_keys=body.innerHTML.match(reg)var links=[]var keys=[]if(location.href.match(/^https?:\/\/pan.baidu.com/)!=null){    var key=location.href.split(&#39;#&#39;)[1]    console.log(key);    var key_input=document.getElementsByTagName(&#39;input&#39;)[0]    key_input.value=key    var but=document.getElementsByClassName(&quot;g-button g-button-blue-large&quot;)[0]    but.click()}else{    var vm=body.innerHTML    for(let link_and_key of links_and_keys)    {        links.push(link_and_key.match(link_reg)[0])        keys.push(link_and_key.match(key_reg)[0])        vm=vm.replace(link_and_key.match(link_reg)[0],link_and_key.match(link_reg)[0]+&#39;#&#39;+link_and_key.match(key_reg)[0])    }    body.innerHTML=vm}})();</code></pre><blockquote><p>现在百度盘的分享都会重定向,所以将提取码保存在链接中失效了</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js,油猴脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕bp神经网络</title>
      <link href="/2020/05/24/zhi-neng-ji-suan/"/>
      <url>/2020/05/24/zhi-neng-ji-suan/</url>
      
        <content type="html"><![CDATA[<p>智能计算的作业,按照公式实现</p><pre><code class="python">import mathimport random# node 三维数组# 第一维表示层# 第二维表示节点# 第三维分别表示输出,到下一层节点的权值,最后一个表示sitadef BP_test(node):    print(&#39;输入数据&#39;)    num1 = int(input())    num2 = int(input())    node[0][0][0] = num1    node[0][1][0] = num2    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj    print(node[-1][0][0])def BP_once(node, y_train, s=0.6):    # 前向计算每个神经元的输出加权和sj和输出    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj            # print(node[layer_count][node_index][0])    y = []    t = y_train    for layer_count in range(1, len(node))[::-1]:        y = t        t = []        for node_index in range(len(node[layer_count])):            oj = node[layer_count][node_index][0]            ej = oj * (1 - oj)            if layer_count == len(node) - 1:                ej *= (y_train[node_index] - oj)                t.append(ej)            else:                we = 0                for i in range(len(node[layer_count + 1])):                    we += y[i] * node[layer_count][node_index][i + 1]                ej *= we            # 先更新sita            node[layer_count][node_index][-1] += s * ej            for i in range(len(node[layer_count - 1])):  # 更新上一层节点的权重                node[layer_count - 1][i][node_index + 1] += s * node[layer_count - 1][i][0] * ej    passdef BP_main(x_train, y_train, s=0.6, t=5000):    random.seed(1)    node = []    node.append([[1, 0.2, -0.3], [0, 0.4, 0.1]])    node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    node.append([[1, 0.1]])    for i in range(len(node)):        for j in range(len(node[i])):            for k in range(len(node[i][j])):                node[i][j][k] = random.random()    train_count = 0    for k in range(t):        for i in range(len(x_train)):  # 选中第几组训练数据            y = []            y.append(y_train[i])            for j in range(len(x_train[i])):                node[0][j][0] = x_train[i][j]            BP_once(node, y, s)    return nodeif __name__ == &#39;__main__&#39;:    # node = []    # node.append([[1, 0.2, -0.3], [0, 0.4, 0.1], [1, -0.5, 0.2]])    # node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    # node.append([[1, 0.1]])    # BP_once(node, [1])    node = BP_main([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 1, 1, 0])    print(&quot;训练结束&quot;)    while True:        BP_test(node)</code></pre><p><code>BP_once:</code>训练一次,可设置学习率</p><p><code>BP_main:</code>反复调用BP_once达到训练多次的目的,并且这里也定义了层数,节点数,和权值的初始化,这个函数有两个参数,第一个是一个二维数组,第一维表示不同的训练数据,第二维表示训练数据的不同值,第二个参数是包含不同训练数据的结果的数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>改进m3u8下载</title>
      <link href="/2020/04/02/gai-jin-m3u8-xia-zai/"/>
      <url>/2020/04/02/gai-jin-m3u8-xia-zai/</url>
      
        <content type="html"><![CDATA[<h2 id="改进m3u8下载"><a href="#改进m3u8下载" class="headerlink" title="改进m3u8下载"></a>改进m3u8下载</h2><blockquote><p>自从用类的方式写了m3u8下载之后,总觉得不太对劲,想改一改</p></blockquote><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>下载是一个过程</p><p>下载器是个实例</p><p>有空把这坑填了</p>]]></content>
      
      
      
        <tags>
            
            <tag> python,爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五子棋AI</title>
      <link href="/2020/03/19/wu-zi-qi-ai/"/>
      <url>/2020/03/19/wu-zi-qi-ai/</url>
      
        <content type="html"><![CDATA[<h2 id="五子棋AI"><a href="#五子棋AI" class="headerlink" title="五子棋AI"></a>五子棋AI</h2><blockquote><p>大二时通过一本书学会了画五子棋的棋盘和棋子,于是写了个AI</p></blockquote><p><a href="https://zhanzhl.github.io/gobang/">效果演示</a></p><pre><code>var canvas =document.getElementById(&quot;canvas&quot;)        var ctx =canvas.getContext(&quot;2d&quot;)        var isblack=true        var arr=new Array()        var wei=new Array()        for(var i=0;i&lt;20;i++)//定义棋子局势        {            arr[i]=new Array();            for(var j=0;j&lt;20;j++)            {                arr[i][j]=0;            }        }        for(i=0;i&lt;20;i++)//设置棋子权重        {            wei[i]=new Array();            for(j=0;j&lt;20;j++)            {                wei[i][j]=20-Math.abs(i+j-20)            }        }        ctx.strokeStyle=&quot;#009688&quot;        ctx.beginPath();        for(i=0;i&lt;19;i++)        {            ctx.moveTo(10+i*20,10)            ctx.lineTo(10+i*20,370)            ctx.moveTo(10,10+20*i)            ctx.lineTo(370,10+i*20)        }        ctx.stroke()        $(&quot;#canvas&quot;).click(function(e){            if(!isblack)            {                alert(&quot;请稍后&quot;)                return            }            console.log(e.offsetX+&quot;,&quot;+e.offsetY)            var thisx=Math.round((e.offsetX-10)/20)            var thisy=Math.round((e.offsetY-10)/20)            if(luozi(thisx,thisy))                myAI()        })        function luozi(thisx,thisy)        {            if(arr[thisx][thisy]==0)            {                ctx.beginPath()                if(isblack)                {                    ctx.fillStyle=&quot;black&quot;                    arr[thisx][thisy]=1                }                else                {                    ctx.fillStyle=&quot;white&quot;                    arr[thisx][thisy]=2                }                ctx.arc(thisx*20+10,thisy*20+10,10,0,Math.PI*2,false)                ctx.fill()                ctx.stroke()                //(0,1)竖直方向胜利                //(1,0)水平方向胜利                //(1,1)从左上到右下                //(1,-1)从左下到右上                testVictory(0,1,thisx,thisy)                testVictory(1,0,thisx,thisy)                testVictory(1,1,thisx,thisy)                testVictory(1,-1,thisx,thisy)                updatewei(thisx,thisy)                isblack=!isblack                return true;            }            return false        }        function testVictory(x,y,newx,newy)        {            var max=1            var tx=newx            var ty=newy            var flag=arr[newx][newy]            while(arr[tx+x][ty+y]==flag)            {                tx=tx+x                ty=ty+y                max++            }            while(arr[newx-x][newy-y]==flag)            {                newx=newx-x                newy=newy-y                max++            }            if(max&gt;4)            {                flag==1?alert(&quot;黑方胜&quot;):alert(&quot;白方胜&quot;)                location.reload()            }        }        function updatewei(thisx,thisy)        {            var i=-4;            var j=-4;            if(thisx+i&lt;=0)                i=1-thisx;            if(thisy+j&lt;=0)                j=1-thisy;                var str=&quot;&quot;;            for(;i&lt;5;i++)            {                for(var j=-4;j&lt;5;j++)                {                    if(arr[thisx+i][thisy+j]==0)                    wei[thisx+i][thisy+j]=testWeight(thisx+i,thisy+j)                    str+=wei[thisx+i][thisy+j]+&quot;(&quot;+(thisx+i)+&quot;,&quot;+(thisy+j)+&quot;)&quot;+&quot;\t&quot;;                }                str+=&quot;\n&quot;            }            console.log(str);        }        function testWeight(thisx,thisy)        {            var weight=20-Math.abs(thisx+thisy-20);            weight+=tance(thisx,thisy,0,1,true)            weight+=tance(thisx,thisy,1,1,true)            weight+=tance(thisx,thisy,1,-1,true)            weight+=tance(thisx,thisy,1,0,true)            weight+=tance(thisx,thisy,0,1,false)            weight+=tance(thisx,thisy,1,1,false)            weight+=tance(thisx,thisy,1,-1,false)            weight+=tance(thisx,thisy,1,0,false)            return weight        }        function tance(newx,newy,x,y,black)        {            var count=0;            var tx=newx;            var ty=newy;            var flag=0;//当前棋子颜色            black?flag=1:flag=2;            var max=5;//探测半径            var mlen=0;//最大连续长度            var iscon=true;//是否连续            while(--max&amp;&amp;tx+x&gt;0&amp;&amp;ty+y&gt;0&amp;&amp;tx+x&lt;20&amp;&amp;ty+y&lt;20)            {                tx=tx+x;                ty=ty+y;                if(arr[tx][ty]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[tx][ty]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            max=5;            while(--max&amp;&amp;newx-x&gt;0&amp;&amp;newy-y&gt;0&amp;&amp;newx-x&lt;20&amp;&amp;newy-y&lt;20)            {                newx=newx-x;                newy=newy-y;                if(arr[newx][newy]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[newx][newy]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            if(mlen&gt;=4)                count=count*1000;            else if(mlen&gt;=3)                count=count*100;            else if(mlen&gt;=2)                count=count*10;            else                count=count;            if(count&lt;0)                count=0;            if(flag==2&amp;&amp;mlen==4)                count*=10;            return count        }        function myAI()//把上面那个写好了,这个函数只是一个遍历的事了        {            var x=1;            var y=1;            var weight=0            for(var i=0;i&lt;20;i++)            {                for(var j=0;j&lt;20;j++)                {                    if(weight&lt;wei[i][j]&amp;&amp;arr[i][j]==0)                    {                        weight=wei[i][j]                        x=i                        y=j                    }                }            }            console.log(&quot;我在&quot;+x+&quot; &quot;+y+&quot;下白子,权重是&quot;+wei[x][y]);            luozi(x,y);        }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python爬取m3u8视频</title>
      <link href="/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/"/>
      <url>/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/</url>
      
        <content type="html"><![CDATA[<h4 id="用python爬取m3u8视频"><a href="#用python爬取m3u8视频" class="headerlink" title="用python爬取m3u8视频"></a>用python爬取m3u8视频</h4><h5 id="m3u8格式"><a href="#m3u8格式" class="headerlink" title="m3u8格式"></a>m3u8格式</h5><p>m3u8是纯文本文档,里面包含了每个视频段的链接</p><p>合起来就是一个完整的视频,如下所示</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:7#EXT-X-MEDIA-SEQUENCE:0#EXTINF:4.712100,4ddf19cc057000000.ts#EXTINF:4.170000,4ddf19cc057000001.ts#EXTINF:4.170000,4ddf19cc057000002.ts</code></pre><p>应注意到<code>4ddf19cc057000000.ts</code>是第一个视频的链接,但是无法直接打开</p><p>因为这个链接是不完整的,需要在这个链接前加上完整的路径才是完整的链接</p><p>如:</p><p>你找到了一个m3u8文件,他的链接是<a href="http://localhost/path/m3u8/index.m3u8" target="_blank" rel="noopener">http://localhost/path/m3u8/index.m3u8</a></p><p>里面第一段视频链接是1.ts</p><p>那么这段视频的完整地址是<a href="http://localhost/path/m3u8/1.ts" target="_blank" rel="noopener">http://localhost/path/m3u8/1.ts</a></p><h5 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h5><p>接受参数:</p><ul><li>文件名</li><li>代理设置</li><li>m3u8链接</li><li>本地路径</li><li>线程个数</li></ul><p>函数设定:</p><ul><li><p>down(ts文件链接)</p><blockquote><p>下载单个ts文件</p></blockquote></li><li><p>parse</p><blockquote><p>读取m3u8文件获取每个ts文件的链接,如果不是完整的链接则补全</p></blockquote></li></ul><h5 id="m3u8downloader"><a href="#m3u8downloader" class="headerlink" title="m3u8downloader"></a>m3u8downloader</h5><pre><code class="python">import requestsimport osfrom concurrent.futures import ThreadPoolExecutor, ALL_COMPLETEDclass m3u8_downloader(object):    def __init__(self, m3u8_url, filename, max_worker=32, proxy=&quot;&quot;, path=os.path.dirname(__file__)):        self.m3u8_url = m3u8_url        self.filename = filename        self.max_worker = max_worker        self.proxy = proxy        self.path = path + os.path.sep;        self.parse()        pass;    def download_file(self, url, filename):        print(filename)        r = requests.get(url, proxies=self.proxy)        while r.status_code != 200:            r = requests.get(url, proxies=self.proxy)        with open(filename, &quot;wb+&quot;) as f:            f.write(r.content)    def parse(self):        pool = ThreadPoolExecutor(self.max_worker)        r = requests.get(self.m3u8_url, timeout=5)        base_url = os.path.dirname(self.m3u8_url)        temp = self.path + &quot;temp&quot; + os.path.sep        if not os.path.exists(temp):            os.makedirs(temp)        i = 0        for line in r.text.split(&#39;\n&#39;):            if line.find(&quot;.ts&quot;) != -1:                if not line.startswith(&quot;http&quot;):                    line = base_url + &#39;/&#39; + line                pool.submit(self.download_file, line, temp + str(i).zfill(8) + &quot;.ts&quot;)                i = i + 1        pool.shutdown(wait=True)        print(self.path)        os.system(&quot;copy /b {}*.ts {}&quot;.format(temp, self.path + self.filename))        os.system(&quot;rmdir /s/q {}&quot;.format(temp))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python,爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>selenium入门</title>
      <link href="/2020/02/27/selenium-ru-men/"/>
      <url>/2020/02/27/selenium-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="selenium入门"><a href="#selenium入门" class="headerlink" title="selenium入门"></a>selenium入门</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code class="shell">pip install selenium</code></pre><h4 id="windows配置"><a href="#windows配置" class="headerlink" title="windows配置"></a>windows配置</h4><ol><li>下载浏览器对应的webDriver</li><li>将解压后的程序添加到环境变量中</li><li>重启电脑</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用说明</title>
      <link href="/2020/02/26/hexo-shi-yong-shuo-ming/"/>
      <url>/2020/02/26/hexo-shi-yong-shuo-ming/</url>
      
        <content type="html"><![CDATA[<h4 id="hexo常用操作"><a href="#hexo常用操作" class="headerlink" title="hexo常用操作"></a>hexo常用操作</h4><ol><li><p>新建文章<code>hexo new 文章标题</code></p></li><li><p>生成静态页面<code>hexo g</code></p></li><li><p>运行本地服务器<code>hexo s</code></p></li><li><p>提交到服务器<code>hexo d</code></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 快速入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
