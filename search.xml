<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>torch游记</title>
      <link href="/ZHANZHl.github.io/2020/12/11/torch-you-ji/"/>
      <url>/ZHANZHl.github.io/2020/12/11/torch-you-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h1><h2 id="从BP开始"><a href="#从BP开始" class="headerlink" title="从BP开始"></a>从BP开始</h2><p>因为之前曾手写过bp神经网络,我认为学习框架从这里开始是比较好的</p><pre><code class="python">import torchimport numpy as npclass Net(torch.nn.Module):    def __init__(self, input_count, hidden_count, out_count):        super(Net, self).__init__()        self.hidden = torch.nn.Linear(input_count, hidden_count)        self.out = torch.nn.Linear(hidden_count, out_count)    def forward(self, x):        x = self.hidden(x)        x = torch.sigmoid(x)        x = self.out(x)        x = torch.sigmoid(x)        return xdef main():    data = np.array([[0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 0]], dtype=&#39;float32&#39;)    inputs, targets = data[:, :2], data[:, 2:]    inputs=torch.Tensor(inputs)    targets=torch.Tensor(targets)    net = Net(2,2,1)    loss_func = torch.nn.MSELoss()    optimizer = torch.optim.SGD(net.parameters(), lr=0.3, momentum=0.9)    for i in range(1000):        net.zero_grad()        out = net(inputs)        loss = loss_func(out, targets)        loss.backward()        optimizer.step()    print(net(inputs))if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="几个概念的理解"><a href="#几个概念的理解" class="headerlink" title="几个概念的理解"></a>几个概念的理解</h2><ol><li><p>激活函数</p><blockquote><p>将正常的输出进行处理的函数</p></blockquote></li><li><p>损失函数</p><blockquote><p>评价输出与目标的差距的函数</p></blockquote></li><li><p>优化函数</p><blockquote><p>根据输出与差别更改权值的函数</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> torch , 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从信号量到抽象队列同步器</title>
      <link href="/ZHANZHl.github.io/2020/11/21/cong-xin-hao-liang-dao-chou-xiang-dui-lie-tong-bu-qi/"/>
      <url>/ZHANZHl.github.io/2020/11/21/cong-xin-hao-liang-dao-chou-xiang-dui-lie-tong-bu-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="一切从信号量开始"><a href="#一切从信号量开始" class="headerlink" title="一切从信号量开始"></a>一切从信号量开始</h1><h2 id="p操作-acquire"><a href="#p操作-acquire" class="headerlink" title="p操作==acquire"></a>p操作==acquire</h2><pre><code class="java">sync.acquireSharedInterruptibly(1);</code></pre><p>这个方法在aqs中实现</p><pre><code class="java">public final void acquireSharedInterruptibly(int arg)        throws InterruptedException {    if (Thread.interrupted())        throw new InterruptedException();    if (tryAcquireShared(arg) &lt; 0)        doAcquireSharedInterruptibly(arg);}</code></pre><p>判断一下当前是不是被标记中断</p><h3 id="调用tryAcquireShared方法"><a href="#调用tryAcquireShared方法" class="headerlink" title="调用tryAcquireShared方法"></a>调用tryAcquireShared方法</h3><blockquote><p>有意思的是 即便这段代码是写在aqs中的,但是aqs并未写出具体的功能</p><p>这段代码由Semaphore中的Nofairsync实现的</p></blockquote><p>于是走到了这里</p><pre><code class="java">final int nonfairTryAcquireShared(int acquires) {    for (;;) {        int available = getState();        int remaining = available - acquires;        if (remaining &lt; 0 ||            compareAndSetState(available, remaining))            return remaining;    }}</code></pre><p>可以看到这里用了cas操作确保原子性,并且还是个自旋锁</p><p>当remaining为负值时或者cas成功会返回remaining</p><p>可以看到在这段代码中特别处理了返回值小于零的情况</p><pre><code class="java">if (tryAcquireShared(arg) &lt; 0)    doAcquireSharedInterruptibly(arg);</code></pre><p>doAcquireSharedInterruptibly处理了需求资源数大于剩余资源数的情况</p><h3 id="doAcquireSharedInterruptibly方法"><a href="#doAcquireSharedInterruptibly方法" class="headerlink" title="doAcquireSharedInterruptibly方法"></a>doAcquireSharedInterruptibly方法</h3><pre><code class="java">final Node node = addWaiter(Node.SHARED);</code></pre><h4 id="addWaiter的代码"><a href="#addWaiter的代码" class="headerlink" title="addWaiter的代码"></a>addWaiter的代码</h4><pre><code class="java">Node node = new Node(mode);for (;;) {    Node oldTail = tail;    if (oldTail != null) {        node.setPrevRelaxed(oldTail);        if (compareAndSetTail(oldTail, node)) {            oldTail.next = node;            return node;        }    } else {        initializeSyncQueue();    }}</code></pre><h5 id="node"><a href="#node" class="headerlink" title="node"></a>node</h5><p>是aqs内的类</p><h5 id="initializeSyncQueue"><a href="#initializeSyncQueue" class="headerlink" title="initializeSyncQueue();"></a>initializeSyncQueue();</h5><pre><code class="java">private final void initializeSyncQueue() {    Node h;    if (HEAD.compareAndSet(this, null, (h = new Node())))        tail = h;}</code></pre><p>讲道理HEAD设置了 TAIL不设置吗</p><p>这里有1次cas,成就成,不成就不成,在外层的循环发现tail为null还会进来的</p><p>只是貌似每次都有new node()</p><h5 id="node-setPrevRelaxed"><a href="#node-setPrevRelaxed" class="headerlink" title="node.setPrevRelaxed"></a>node.setPrevRelaxed</h5><p>不清楚有什么用</p><h5 id="compareAndSetTail"><a href="#compareAndSetTail" class="headerlink" title="compareAndSetTail"></a>compareAndSetTail</h5><pre><code class="java">private final boolean compareAndSetTail(Node expect, Node update) {    return TAIL.compareAndSet(this, expect, update);}</code></pre><p>想不到在这里设置TAIL</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>在addWaiter里如果没有设置头节点尾节点,则设置</p><p>根据给定mode创建新node,这个节点应当成为尾节点</p><p>有一个问题就是这个节点并没有设置state,prev,next什么的</p><p>这里只是完成初始化队列,和设置头尾节点的工作</p><h4 id="node-predecessor"><a href="#node-predecessor" class="headerlink" title="node.predecessor();"></a>node.predecessor();</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程 线程</title>
      <link href="/ZHANZHl.github.io/2020/10/13/xian-dai-cao-zuo-xi-tong/"/>
      <url>/ZHANZHl.github.io/2020/10/13/xian-dai-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>有两大主题</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><h4 id="忙等的自旋锁"><a href="#忙等的自旋锁" class="headerlink" title="忙等的自旋锁"></a>忙等的自旋锁</h4><p>形似 while(lock);</p><p>但是这一大类都需要类似cas/tsl保证操作的原子性</p><p>否则很难说不出错</p><h4 id="非忙等的信号量"><a href="#非忙等的信号量" class="headerlink" title="非忙等的信号量"></a>非忙等的信号量</h4><p>用链表保存一个未获得对应资源的队列</p><p>当对应资源释放时 检查信号量 执行对应操作</p><p>例如有1个资源</p><p>第一个线程成功申请</p><p>第二个线程发现此时资源数为0,将资源数-1,并把当前任务添加到队列中</p><p> 当第一个线程执行完毕,</p><p>将信号量+1,若此时信号量&lt;=0,从队列中唤醒一个任务</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>通过编译器保证一段代码同时只有一个线程访问</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>读-复制-更新</p><p>保证访问到的要么是完全的旧版本,要么是完全的新版本</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>调度算法有一个区别 可抢占式/不可抢占式</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>最简单的一种</p><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>问题在于怎么判断一个作业的 剩余运行时间/运行时间</p><h4 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h4><p>每个进程运行一个时间片</p><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>书上说 实践可行比理论上可行难太多</p><p>我的理解是 这个算法实际上减少了(运行时间长的进程)上下文切换的次数,但对于运行时间少的进程并不友好</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>段式 面向程序员</p><p>页式 将程序分散在内存的不同位置,减少内存碎片</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>页式存储为了加快访问需要快表</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h4><h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><p>理想中的算法,用来衡量其他算法</p><h4 id="not-recently-used"><a href="#not-recently-used" class="headerlink" title="not recently used"></a>not recently used</h4><p>翻译为 最近未使用 我觉得我听不懂</p><p>大致意思是从不是最近使用的页面中随机选择一个置换</p><h4 id="第二次机会-时钟"><a href="#第二次机会-时钟" class="headerlink" title="第二次机会/时钟"></a>第二次机会/时钟</h4><p>二者的区别是 时钟类似一个循环链表 首尾相连</p><p>每次将当前位置r标志位置0</p><p>若当前位置r为0则淘汰此页面</p><h4 id="LRU最近最少使用-NFU-老化算法"><a href="#LRU最近最少使用-NFU-老化算法" class="headerlink" title="LRU最近最少使用/NFU/老化算法"></a>LRU最近最少使用/NFU/老化算法</h4><p>LRU和老化算法的区别是 老化算法右移一位并加在最左边</p><p>LRU是每次使用一个页面时,移动到链表最前面并将次数加一</p><p>但是这样的操作太慢</p><p>近似的模拟时NFU只保存使用次数,不考虑多久未使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 进程 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp算法</title>
      <link href="/ZHANZHl.github.io/2020/09/29/kmp-suan-fa/"/>
      <url>/ZHANZHl.github.io/2020/09/29/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><blockquote><p>照着算法导论写了kmp算法</p></blockquote><pre><code class="python">def KMP(T, P):    &quot;&quot;&quot;    :param T:    :param P: 待匹配字符串    :return:    &quot;&quot;&quot;    n = len(T)    m = len(P)    k = 0    fail = get_fail(P)    for i in range(n):        while k &gt; 0 and T[i] != P[k]:            k = fail[k - 1]        if T[i] == P[k]:            k += 1        if k == m:            return True    return Falsedef get_fail(P):    n = len(P)    fail = [0] * n    k = 0    for j in range(1, n):        while k &gt; 0 and P[j] != P[k]:            k = fail[k - 1]        if P[j] == P[k]:            k = k + 1        fail[j] = k    return fail</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> kmp,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/ZHANZHl.github.io/2020/09/11/kuai-su-pai-xu/"/>
      <url>/ZHANZHl.github.io/2020/09/11/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<!--之前其实也实现过快速排序也能理解快速排序的原理但其实实现的不是很熟练边界难以掌握希望这一次能够完全弄明白--><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>根据算法导论,实现如下</p><pre><code>def quicksort(nums, l, r):    if l &lt; r:        q = partition(nums, l, r)        quicksort(nums, l, q - 1)        quicksort(nums, q + 1, r)def partition(nums, l, r):    x = nums[r]    i = l - 1    for j in range(l, r):        if nums[j] &lt;= x:            i = i + 1            nums[i], nums[j] = nums[j], nums[i]    nums[i + 1], nums[r] = nums[r], nums[i + 1]    return i + 1</code></pre><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><h4 id="quicksort"><a href="#quicksort" class="headerlink" title="quicksort"></a>quicksort</h4><p>没什么好说的,就是普通的二分处理</p><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>选定一元素,默认为最右侧元素</p><p>维护一个比选定元素小的子数组</p><p>这个子数组从0开始</p><p>每遇到比选定元素小于等于的元素使子数组扩张1个</p><p>并交换选定位置</p><p>最后交换选定元素到指定位置</p><h3 id="随机化版本"><a href="#随机化版本" class="headerlink" title="随机化版本"></a>随机化版本</h3><!--卧槽这就是大师吗?讲道理这里真的牛逼--><pre><code class="python">def random_partition(nums, l, r):    i = random.randint(l, r)    nums[i], nums[r] = nums[r], nums[i]    return partition(nums, l, r)def random_quicksort(nums, l, r):    if l &lt; r:        q = random_partition(nums, l, r)        random_quicksort(nums, l, q - 1)        random_quicksort(nums, q + 1, r)</code></pre><h3 id="迭代版本"><a href="#迭代版本" class="headerlink" title="迭代版本"></a>迭代版本</h3><pre><code class="python">def quicksort(nums, l, r):    st = [(l, r)]    while len(st) &gt; 0:        top = st.pop()        left, right = top[0], top[1]        if left &lt; right:            i = partition(nums, left, right)            st.append((left, i - 1))            st.append((i + 1, right))def partition(nums, l, r):    x = nums[r]    i = l - 1    for j in range(l, r):        if nums[j] &lt;= x:            i += 1            nums[i], nums[j] = nums[j], nums[i]    nums[i + 1], nums[r] = nums[r], nums[i + 1]    return i + 1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 快速排序,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我印象中的http协议</title>
      <link href="/ZHANZHl.github.io/2020/09/02/wo-yin-xiang-zhong-de-http-xie-yi/"/>
      <url>/ZHANZHl.github.io/2020/09/02/wo-yin-xiang-zhong-de-http-xie-yi/</url>
      
        <content type="html"><![CDATA[<!--面试官问我 http链接能复用吗?我被这道题蒙到了,其实我看过长连接短链接的问题而且就算当时忘了也可以从下往上想所谓http链接不就是在tcp上发个报文过去服务器接收到消息再返回吗如果建立的tcp链接是一个怎么就不能复用了--><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>所以,到现在我脑海中的http协议是这样的:</p><ol><li>建立tcp连接</li><li>由客户端首先发起请求,格式固定</li><li>服务端接收到请求后,返回响应</li></ol><p>至于双方请求细节,由头部确定</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>在请求中cookie:key1=value1;</p><p>在响应中set-cookie: key:value;</p><p>在响应中的cookie只能一条一条设置,分号后面是设置这个cookie的作用于之类的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试,计算机网络,http,抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表示</title>
      <link href="/ZHANZHl.github.io/2020/08/29/shen-ru-li-jie-ji-suan-ji-xi-tong/"/>
      <url>/ZHANZHl.github.io/2020/08/29/shen-ru-li-jie-ji-suan-ji-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>整数</p><ul><li>原码:首位符号位,其余正常的二进制</li><li>反码:首位为负值,并且需要+1,其余为正常值</li><li>补码:首位为负值,其余位为正常值</li></ul></li><li><p>浮点数</p><p>首位符号位,阶码,尾数</p><ul><li><p>阶码</p><p>我以为,阶码可以将其按位取反去理解</p><p>当全为0时特殊处理</p><p>例如 0001 可以理解为 1110 即 -6</p></li></ul><p>例: 0 0000 0001</p><p>首位为0 ,正数</p><p>阶码位置字面表示为0 E=1-(2^(4-1)-1)=-6 权重为2^(-6)=1/64</p><p>尾数为1/16</p><p>结果为 1/64*1/16</p><p>0 0001 0001</p><p>首位为0 ,正数</p><p>阶码位置字面表示为1 E=1-(2^(4-1)-1)=-6 权重为2^(-6)=1/64</p><p>尾数为17/16</p><p>结果为 1/64*17/16</p></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>溢出都会保留低位作为新值</p><p>强制转换不改变位,只改变解释位的方法 </p><h4 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h4><p>对于一个整数</p><p>大端: 将高位存在低地址</p><p>小端: 将低位存在低地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马拉车算法</title>
      <link href="/ZHANZHl.github.io/2020/08/29/ma-la-che-suan-fa/"/>
      <url>/ZHANZHl.github.io/2020/08/29/ma-la-che-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><blockquote><p>刷leetcode时,遇到了<a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">这道题</a></p></blockquote><p>粗一分析,发现本质上是在找这个字符串的最长回文前缀,将非前缀的转置加到前面就是结果了</p><h3 id="超时代码"><a href="#超时代码" class="headerlink" title="超时代码"></a>超时代码</h3><pre><code class="python">class Solution:    def checkP(self, s: str):        for i in range(int(len(s) / 2)):            if s[i] != s[len(s) - 1 - i]:                return False        return True    def shortestPalindrome(self, s: str) -&gt; str:        if self.checkP(s):            return s        # t = &#39;&#39;        # for i in range(len(s))[::-1]:        #     t = t + s[i]        #     p = t + s        #     if self.checkP(p):        #         return p        n=len(s)        max_num=0        for i in range(2,n):            if self.checkP(s[:i]):                max_num=max(max_num,i)        if max_num==0:            return s[1:][::-1]+s        return s[max_num:][::-1]+s</code></pre><p>每个中心遍历一遍,重复判断回文</p><p>时间复杂度O(n^2)</p><h3 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h3><pre><code class="python">class Solution:    def checkP(self, s: str):        for i in range(int(len(s) / 2)):            if s[i] != s[len(s) - 1 - i]:                return False        return True    def shortestPalindrome(self, s: str) -&gt; str:        def manacher(s1: str):            s1 = &quot;#&quot; + &quot;#&quot;.join(s1) + &quot;#&quot;            n = len(s1)            p = [0] * n            center, max_right = 0, 0            for i in range(n):                length = 0                if i &lt; max_right:                    length = min(p[center * 2 - i], max_right - i)                while i - length &gt;= 0 and i + length &lt; n and s1[i + length] == s1[i - length]:                    if length + i &gt; max_right:                        max_right = length + i                        center = i                    length += 1                p[i] = length - 1            return p        if self.checkP(s):            return s        n = len(s)        p = manacher(s)        max_num = 0        for i in range(len(p)):            if i - p[i] == 0:                max_num = max(max_num, (i + p[i])//2)        if max_num == 0:            return s[1:][::-1] + s        return s[max_num:][::-1] + s</code></pre><p>时间复杂度O(n)</p><p>参考了<a href="https://www.cxyxiaowu.com/2665.html" target="_blank" rel="noopener">这篇文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法,回文字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次pdf去水印的流程</title>
      <link href="/ZHANZHl.github.io/2020/08/20/pdf-qu-shui-yin/"/>
      <url>/ZHANZHl.github.io/2020/08/20/pdf-qu-shui-yin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在网上找到了一份学习资料,但是上面的水印十分影响阅读,我想把水印去掉</p></blockquote><ol><li><p>首先想到的就是python有没有什么库可以操作pdf</p><blockquote><p>经过搜索发现有人用pypdf2去水印,并且贴上了代码:<a href="https://www.jianshu.com/p/f449a6e86602" target="_blank" rel="noopener">链接</a></p><p>试着运行了下这份代码,没有解决我的问题</p></blockquote></li><li><p>在查看了pypdf2官方文档,debug无果之后,尝试打印了第一页所有的格式,发现只有如下几种:</p><blockquote><p>[b’q’, b’BT’, b’Tf’, b’Tc’, b’Tm’, b’g’, b’G’, b’TJ’, b’ET’, b’Q’, b’Tr’, b’w’, b’cm’, b’re’, b’f*’, b’BDC’, b’gs’, b’Do’, b’EMC’]</p></blockquote></li><li><p>尝试依次去除一种格式,观察效果:</p><blockquote><pre><code>Tm 格式全去掉为空Tf 格式去掉为乱码g 格式全去掉出现小黑快cm 格式去掉水印出现倾斜gs 格式去掉水印变黑了Do 格式去掉水印消失了</code></pre></blockquote></li><li><p>所以说,只要把每一页的Do格式的文本替换为空,就可以达到去水印的目的</p></li><li><p>但是我觉着到目前为止的东西都太体力了,我想要一种快捷的做法</p></li><li><p>又去网上找到了一篇介绍pdf文件格式的文章, <a href="https://lazymind.me/2017/10/pdf-structure/" target="_blank" rel="noopener">链接</a></p></li><li><p>在程序中打印了格式为Do的数据,输出如下</p><blockquote><p>[‘/KSPX1’]</p></blockquote></li><li><p>用文本编辑器打开pdf文件并搜索,得到这样的内容</p><p><img src="img.jpg" alt=""></p></li><li><p>将<code>&lt;&lt;/KSPX1 5548 0 R &gt;&gt;</code>删除可以删除一页的水印</p></li><li><p>而由前面的文章可以知道,这个是一个间接引用,将关键字改为5548 0 obj可以搜索到</p><p><img src="img2.jpg" alt=""></p></li><li><p>将这一段删掉即可去除整个pdf的水印</p></li></ol><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ol><li>如果一页的水印只有一个的话,可以尝试计算出对应格式出现的次数,优先删除出现次数为1的格式</li><li>到现在也不明白所谓的格式是什么</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> pdf,小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像加速配置</title>
      <link href="/ZHANZHl.github.io/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/"/>
      <url>/ZHANZHl.github.io/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/</url>
      
        <content type="html"><![CDATA[<pre><code class="json">  &quot;registry-mirrors&quot;: [    &quot;https://hub-mirror.c.163.com/&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;https://reg-mirror.qiniu.com&quot;,    &quot;https://mirror.ccs.tencentyun.com&quot;  ],</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker,环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程</title>
      <link href="/ZHANZHl.github.io/2020/05/25/python-duo-xian-cheng/"/>
      <url>/ZHANZHl.github.io/2020/05/25/python-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>现在从头开始梳理python,学习一下多线程编程</p></blockquote><p>首先看一下官网的介绍</p><blockquote><p>该模块的设计基于 Java的线程模型。 但是，在Java里面，锁和条件变量是每个对象的基础特性，而在Python里面，这些被独立成了单独的对象。 Python 的 <code>Thread</code> 类只是 Java 的 <code>Thread</code> 类的一个子集；目前还没有优先级，没有线程组，线程还不能被销毁、停止、暂停、恢复或中断。 Java 的 Thread 类的静态方法在实现时会映射为模块级函数。</p></blockquote><h3 id="从信号量开始"><a href="#从信号量开始" class="headerlink" title="从信号量开始"></a>从信号量开始</h3><pre><code class="python">def __init__(self, value=1):    if value &lt; 0:        raise ValueError(&quot;semaphore initial value must be &gt;= 0&quot;) #判断了下value    self._cond = Condition(Lock()) #初始化了Condition    self._value = value</code></pre><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><pre><code class="python">if not blocking and timeout is not None:    raise ValueError(&quot;can&#39;t specify timeout for non-blocking acquire&quot;) # 如果设置了非阻塞的话,就不应该有超时时间rc = False # 结果endtime = None with self._cond: #应当是通过上下文管理器申请了锁,具体等会看(__enter__)    while self._value == 0: # 如果资源不足        if not blocking: # 非阻塞的话,不管怎么样直接返回            break        if timeout is not None: # 如果设置了超时时间            if endtime is None:                endtime = _time() + timeout # _time 实际上是time.monotonic 用这个函数判断时间间隔,确定这个函数等到什么时候就不再等了            else:                timeout = endtime - _time() # 这里的timeout 是计算了下还要等多久                if timeout &lt;= 0: # 如果已经超时了当然要退出                    break        self._cond.wait(timeout) # 可能是等待唤醒吧    else: # 没什么好写的,就是正常的申请资源吧        self._value -= 1         rc = Truereturn rc</code></pre><p>同时还设置了下 上下文管理器<code>__enter__ = acquire</code></p><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><pre><code class="python">with self._cond: # 这好像主要是Condition    self._value += 1    self._cond.notify()</code></pre><p>同<code>acquire</code>一样,设置了退出上下文管理器的代码</p><pre><code class="python">def __exit__(self, t, v, tb):    self.release()</code></pre><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><pre><code class="python">def __init__(self, lock=None): # 多有意思,信号量用了condition ,condition用了lock 等会看lock吧    if lock is None:        lock = RLock() # 默认是RLock    self._lock = lock    self.acquire = lock.acquire    self.release = lock.release    # 鬼知道接下来这几个函数是什么意思,不过代码的意思是 如果lock实现了这些方法,那么这个condition的这些方法应当被覆盖掉    try:        self._release_save = lock._release_save    except AttributeError:        pass    try:        self._acquire_restore = lock._acquire_restore    except AttributeError:        pass    try:        self._is_owned = lock._is_owned    except AttributeError:        pass    self._waiters = _deque() # 来了,等待队列</code></pre><h4 id="condition的上下文管理器完全是lock的"><a href="#condition的上下文管理器完全是lock的" class="headerlink" title="condition的上下文管理器完全是lock的"></a>condition的上下文管理器完全是lock的</h4><pre><code class="python">def __enter__(self):    return self._lock.__enter__()def __exit__(self, *args):    return self._lock.__exit__(*args)</code></pre><h4 id="is-owned"><a href="#is-owned" class="headerlink" title="_is_owned"></a>_is_owned</h4><pre><code class="python">def _is_owned(self): # 不知道什么意思    if self._lock.acquire(0):        self._lock.release()        return False    else:        return True</code></pre><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><pre><code class="python">if not self._is_owned():    raise RuntimeError(&quot;cannot wait on un-acquired lock&quot;)waiter = _allocate_lock() # _thread.allocate_lock 我觉着这个方法可以去看文档   https://docs.python.org/zh-cn/3/library/_thread.htmlwaiter.acquire() self._waiters.append(waiter) # 将新创建的锁添加到双端队列中saved_state = self._release_save() # 默认的实现并未返回任何内容gotit = Falsetry:    if timeout is None: # timeout 是函数的参数        waiter.acquire() # 实际上如果没有release 会在这里一直卡住 这个代码等同于 waiter.acquire(1,-1)        gotit = True # 如果能够到这里说明一定成功获取到了    else:        if timeout &gt; 0: # 如果time小于等于0 则无限等待            gotit = waiter.acquire(True, timeout) # condition的wait实际上是执行了这个代码        else:            gotit = waiter.acquire(False)    return gotitfinally: # 看不懂    self._acquire_restore(saved_state)    if not gotit:        try:            self._waiters.remove(waiter)        except ValueError:            pass</code></pre><h4 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h4><pre><code class="python">if not self._is_owned(): # 怎么上来都这一套啊    raise RuntimeError(&quot;cannot notify on un-acquired lock&quot;)all_waiters = self._waiterswaiters_to_notify = _deque(_islice(all_waiters, n)) # 含有n个单位的_deque,n是这个函数的参数if not waiters_to_notify:    returnfor waiter in waiters_to_notify:    waiter.release()    try:        all_waiters.remove(waiter)    except ValueError: # 这个是处理之后all_waiters发生了变化,没有了waiter这个值        pass</code></pre><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>以之前出现过的RLock为例</p><pre><code class="python"># 大概意思是 如果有c实现的RLock 就用c的 没有就用python的if _CRLock is None:    return _PyRLock(*args, **kwargs)return _CRLock(*args, **kwargs)</code></pre><p>用python实现的RLock是这样的</p><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><pre><code class="python">def __init__(self):    self._block = _allocate_lock() # 见识过了,官网也有介绍    self._owner = None    self._count = 0</code></pre><h4 id="acquire-1"><a href="#acquire-1" class="headerlink" title="acquire"></a>acquire</h4><pre><code class="python">me = get_ident() # 返回线程idif self._owner == me: # 如果线程id和保存的一致    self._count += 1    return 1rc = self._block.acquire(blocking, timeout) # blocking timeout 都是参数if rc: # 这么看来,如果线程id不一致,状态也会化为初始值    self._owner = me    self._count = 1return rc</code></pre><h4 id="release-1"><a href="#release-1" class="headerlink" title="release"></a>release</h4><pre><code class="python">if self._owner != get_ident():    raise RuntimeError(&quot;cannot release un-acquired lock&quot;)self._count = count = self._count - 1 # 重入次数减一if not count:    self._owner = None    self._block.release()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕bp神经网络</title>
      <link href="/ZHANZHl.github.io/2020/05/24/zhi-neng-ji-suan/"/>
      <url>/ZHANZHl.github.io/2020/05/24/zhi-neng-ji-suan/</url>
      
        <content type="html"><![CDATA[<p>智能计算的作业,按照公式实现</p><pre><code class="python">import mathimport random# node 三维数组# 第一维表示层# 第二维表示节点# 第三维分别表示输出,到下一层节点的权值,最后一个表示sitadef BP_test(node):    print(&#39;输入数据&#39;)    num1 = int(input())    num2 = int(input())    node[0][0][0] = num1    node[0][1][0] = num2    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj    print(node[-1][0][0])def BP_once(node, y_train, s=0.6):    # 前向计算每个神经元的输出加权和sj和输出    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj            # print(node[layer_count][node_index][0])    y = []    t = y_train    for layer_count in range(1, len(node))[::-1]:        y = t        t = []        for node_index in range(len(node[layer_count])):            oj = node[layer_count][node_index][0]            ej = oj * (1 - oj)            if layer_count == len(node) - 1:                ej *= (y_train[node_index] - oj)                t.append(ej)            else:                we = 0                for i in range(len(node[layer_count + 1])):                    we += y[i] * node[layer_count][node_index][i + 1]                ej *= we            # 先更新sita            node[layer_count][node_index][-1] += s * ej            for i in range(len(node[layer_count - 1])):  # 更新上一层节点的权重                node[layer_count - 1][i][node_index + 1] += s * node[layer_count - 1][i][0] * ej    passdef BP_main(x_train, y_train, s=0.6, t=5000):    random.seed(1)    node = []    node.append([[1, 0.2, -0.3], [0, 0.4, 0.1]])    node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    node.append([[1, 0.1]])    for i in range(len(node)):        for j in range(len(node[i])):            for k in range(len(node[i][j])):                node[i][j][k] = random.random()    train_count = 0    for k in range(t):        for i in range(len(x_train)):  # 选中第几组训练数据            y = []            y.append(y_train[i])            for j in range(len(x_train[i])):                node[0][j][0] = x_train[i][j]            BP_once(node, y, s)    return nodeif __name__ == &#39;__main__&#39;:    # node = []    # node.append([[1, 0.2, -0.3], [0, 0.4, 0.1], [1, -0.5, 0.2]])    # node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    # node.append([[1, 0.1]])    # BP_once(node, [1])    node = BP_main([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 1, 1, 0])    print(&quot;训练结束&quot;)    while True:        BP_test(node)</code></pre><p><code>BP_once:</code>训练一次,可设置学习率</p><p><code>BP_main:</code>反复调用BP_once达到训练多次的目的,并且这里也定义了层数,节点数,和权值的初始化,这个函数有两个参数,第一个是一个二维数组,第一维表示不同的训练数据,第二维表示训练数据的不同值,第二个参数是包含不同训练数据的结果的数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="/ZHANZHl.github.io/2020/03/19/qian-duan/"/>
      <url>/ZHANZHl.github.io/2020/03/19/qian-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="js跳转到不同的url"><a href="#js跳转到不同的url" class="headerlink" title="js跳转到不同的url"></a>js跳转到不同的url</h2><ol><li><p>设置不同的button</p></li><li><p>为每个button设置onclick事件</p></li><li><p>事件内容如下:</p><pre><code class="javascript">function 方法名() {     document.你的表单名.action=&quot;要跳转到的url&quot;     document.你的表单名.submit()}</code></pre></li></ol><h2 id="五子棋"><a href="#五子棋" class="headerlink" title="五子棋"></a>五子棋</h2><blockquote><p>大二时通过一本书学会了画五子棋的棋盘和棋子,于是写了个AI</p></blockquote><p><a href="https://zhanzhl.github.io/gobang/">效果演示</a></p><pre><code>var canvas =document.getElementById(&quot;canvas&quot;)        var ctx =canvas.getContext(&quot;2d&quot;)        var isblack=true        var arr=new Array()        var wei=new Array()        for(var i=0;i&lt;20;i++)//定义棋子局势        {            arr[i]=new Array();            for(var j=0;j&lt;20;j++)            {                arr[i][j]=0;            }        }        for(i=0;i&lt;20;i++)//设置棋子权重        {            wei[i]=new Array();            for(j=0;j&lt;20;j++)            {                wei[i][j]=20-Math.abs(i+j-20)            }        }        ctx.strokeStyle=&quot;#009688&quot;        ctx.beginPath();        for(i=0;i&lt;19;i++)        {            ctx.moveTo(10+i*20,10)            ctx.lineTo(10+i*20,370)            ctx.moveTo(10,10+20*i)            ctx.lineTo(370,10+i*20)        }        ctx.stroke()        $(&quot;#canvas&quot;).click(function(e){            if(!isblack)            {                alert(&quot;请稍后&quot;)                return            }            console.log(e.offsetX+&quot;,&quot;+e.offsetY)            var thisx=Math.round((e.offsetX-10)/20)            var thisy=Math.round((e.offsetY-10)/20)            if(luozi(thisx,thisy))                myAI()        })        function luozi(thisx,thisy)        {            if(arr[thisx][thisy]==0)            {                ctx.beginPath()                if(isblack)                {                    ctx.fillStyle=&quot;black&quot;                    arr[thisx][thisy]=1                }                else                {                    ctx.fillStyle=&quot;white&quot;                    arr[thisx][thisy]=2                }                ctx.arc(thisx*20+10,thisy*20+10,10,0,Math.PI*2,false)                ctx.fill()                ctx.stroke()                //(0,1)竖直方向胜利                //(1,0)水平方向胜利                //(1,1)从左上到右下                //(1,-1)从左下到右上                testVictory(0,1,thisx,thisy)                testVictory(1,0,thisx,thisy)                testVictory(1,1,thisx,thisy)                testVictory(1,-1,thisx,thisy)                updatewei(thisx,thisy)                isblack=!isblack                return true;            }            return false        }        function testVictory(x,y,newx,newy)        {            var max=1            var tx=newx            var ty=newy            var flag=arr[newx][newy]            while(arr[tx+x][ty+y]==flag)            {                tx=tx+x                ty=ty+y                max++            }            while(arr[newx-x][newy-y]==flag)            {                newx=newx-x                newy=newy-y                max++            }            if(max&gt;4)            {                flag==1?alert(&quot;黑方胜&quot;):alert(&quot;白方胜&quot;)                location.reload()            }        }        function updatewei(thisx,thisy)        {            var i=-4;            var j=-4;            if(thisx+i&lt;=0)                i=1-thisx;            if(thisy+j&lt;=0)                j=1-thisy;                var str=&quot;&quot;;            for(;i&lt;5;i++)            {                for(var j=-4;j&lt;5;j++)                {                    if(arr[thisx+i][thisy+j]==0)                    wei[thisx+i][thisy+j]=testWeight(thisx+i,thisy+j)                    str+=wei[thisx+i][thisy+j]+&quot;(&quot;+(thisx+i)+&quot;,&quot;+(thisy+j)+&quot;)&quot;+&quot;\t&quot;;                }                str+=&quot;\n&quot;            }            console.log(str);        }        function testWeight(thisx,thisy)        {            var weight=20-Math.abs(thisx+thisy-20);            weight+=tance(thisx,thisy,0,1,true)            weight+=tance(thisx,thisy,1,1,true)            weight+=tance(thisx,thisy,1,-1,true)            weight+=tance(thisx,thisy,1,0,true)            weight+=tance(thisx,thisy,0,1,false)            weight+=tance(thisx,thisy,1,1,false)            weight+=tance(thisx,thisy,1,-1,false)            weight+=tance(thisx,thisy,1,0,false)            return weight        }        function tance(newx,newy,x,y,black)        {            var count=0;            var tx=newx;            var ty=newy;            var flag=0;//当前棋子颜色            black?flag=1:flag=2;            var max=5;//探测半径            var mlen=0;//最大连续长度            var iscon=true;//是否连续            while(--max&amp;&amp;tx+x&gt;0&amp;&amp;ty+y&gt;0&amp;&amp;tx+x&lt;20&amp;&amp;ty+y&lt;20)            {                tx=tx+x;                ty=ty+y;                if(arr[tx][ty]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[tx][ty]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            max=5;            while(--max&amp;&amp;newx-x&gt;0&amp;&amp;newy-y&gt;0&amp;&amp;newx-x&lt;20&amp;&amp;newy-y&lt;20)            {                newx=newx-x;                newy=newy-y;                if(arr[newx][newy]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[newx][newy]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            if(mlen&gt;=4)                count=count*1000;            else if(mlen&gt;=3)                count=count*100;            else if(mlen&gt;=2)                count=count*10;            else                count=count;            if(count&lt;0)                count=0;            if(flag==2&amp;&amp;mlen==4)                count*=10;            return count        }        function myAI()//把上面那个写好了,这个函数只是一个遍历的事了        {            var x=1;            var y=1;            var weight=0            for(var i=0;i&lt;20;i++)            {                for(var j=0;j&lt;20;j++)                {                    if(weight&lt;wei[i][j]&amp;&amp;arr[i][j]==0)                    {                        weight=wei[i][j]                        x=i                        y=j                    }                }            }            console.log(&quot;我在&quot;+x+&quot; &quot;+y+&quot;下白子,权重是&quot;+wei[x][y]);            luozi(x,y);        }</code></pre><h2 id="油猴百度网盘自动填写提取码脚本"><a href="#油猴百度网盘自动填写提取码脚本" class="headerlink" title="油猴百度网盘自动填写提取码脚本"></a>油猴百度网盘自动填写提取码脚本</h2><pre><code class="javascript">// ==UserScript==// @name         百度网盘自动填写提取码// @namespace    http://tampermonkey.net/// @version      0.2// @description  try to take over the world!// @author       zhanzhi// @match        https://pan.baidu.com/*// @grant        none// ==/UserScript==(function() {    &#39;use strict&#39;;var body=document.getElementsByTagName(&#39;body&#39;)[0]var reg=/https?:\/\/pan.baidu.com\/s\/.{23}.*?提取码.*?([0-9a-zA-Z]{4})/svar link_reg=/^https?:\/\/pan.baidu.com\/s\/.(.{22})/var key_reg=/[0-9a-zA-Z]{4}$/var links_and_keys=body.innerHTML.match(reg)var links=[]var keys=[]if(location.href.match(/^https?:\/\/pan.baidu.com/)!==null){    var key=location.href.split(&#39;#&#39;)[1]    var key_input=document.getElementsByTagName(&#39;input&#39;)[0]    if(typeof key ===&quot;string&quot;)    {        key_input.value=key        var but=document.getElementsByClassName(&quot;g-button g-button-blue-large&quot;)[0]        but.click()    }}else{    var vm=body.innerHTML    links.push(links_and_keys[0].match(link_reg)[0])    keys.push(links_and_keys[1].match(key_reg)[0])    var surl=links_and_keys[0].match(link_reg)[1]    var url=&#39;https://pan.baidu.com/share/init?surl=&#39;+surl    vm=vm.replace(links_and_keys[0].match(link_reg)[0],url+&#39;#&#39;+links_and_keys[0].match(key_reg)[0])    body.innerHTML=vm}})();</code></pre><blockquote><p>经观察,虽然百度盘的分享链接会重定向</p><p>不过重定向的url都是有规律的</p><p>如分享链接为<a href="https://pan.baidu.com/s/1.{22}" target="_blank" rel="noopener">https://pan.baidu.com/s/1.{22}</a></p><p>那么填写提取码的链接就是<a href="https://pan.baidu.com/share/init?surl=加上上面.{22}匹配到的内容" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=加上上面.{22}匹配到的内容</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python爬取m3u8视频</title>
      <link href="/ZHANZHl.github.io/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/"/>
      <url>/ZHANZHl.github.io/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/</url>
      
        <content type="html"><![CDATA[<h4 id="用python爬取m3u8视频"><a href="#用python爬取m3u8视频" class="headerlink" title="用python爬取m3u8视频"></a>用python爬取m3u8视频</h4><h4 id="m3u8格式"><a href="#m3u8格式" class="headerlink" title="m3u8格式"></a>m3u8格式</h4><p>m3u8是纯文本文档,里面包含了每个视频段的链接</p><p>合起来就是一个完整的视频,如下所示</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:7#EXT-X-MEDIA-SEQUENCE:0#EXTINF:4.712100,4ddf19cc057000000.ts#EXTINF:4.170000,4ddf19cc057000001.ts#EXTINF:4.170000,4ddf19cc057000002.ts</code></pre><p>应注意到<code>4ddf19cc057000000.ts</code>是第一个视频的链接,但是无法直接打开</p><p>因为这个链接是不完整的,需要在这个链接前加上完整的路径才是完整的链接</p><p>如:</p><p>你找到了一个m3u8文件,他的链接是<a href="http://localhost/path/m3u8/index.m3u8" target="_blank" rel="noopener">http://localhost/path/m3u8/index.m3u8</a></p><p>里面第一段视频链接是1.ts</p><p>那么这段视频的完整地址是<a href="http://localhost/path/m3u8/1.ts" target="_blank" rel="noopener">http://localhost/path/m3u8/1.ts</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>import requestsimport osfrom concurrent.futures import ThreadPoolExecutor, ALL_COMPLETEDm3u8_url = &#39;m3u8的链接&#39;  # m3u8的链接filename = &#39;22&#39;  # 下载后保存的名字max_worker = 8  # 线程数proxy = {&#39;http&#39;: &#39;http://127.0.0.1:1080&#39;, &#39;https&#39;: &#39;http://127.0.0.1:1080&#39;}  # 代理设置path = &quot;下载到哪个路径&quot;  # 下载到哪个路径def download_file(url, filename):    r = requests.get(url, proxies=proxy)    while r.status_code != 200:        r = requests.get(url, proxies=proxy)        print(filename,&#39;请求超时&#39;)    with open(filename, &quot;wb+&quot;) as f:        f.write(r.content)def parse():    pool = ThreadPoolExecutor(max_worker)    r = requests.get(m3u8_url, timeout=5, proxies=proxy)    base_url = os.path.dirname(m3u8_url)    temp = path + &quot;temp&quot; + os.path.sep    if not os.path.exists(temp):        os.makedirs(temp)    i = 0    for line in r.text.split(&#39;\n&#39;):        if line.find(&quot;.ts&quot;) != -1:            if not line.startswith(&quot;http&quot;):                line = base_url + &#39;/&#39; + line            pool.submit(download_file, line, temp + str(i).zfill(8) + &quot;.ts&quot;)            i = i + 1    pool.shutdown(wait=True)    os.system(&quot;cd {} &amp;&amp;copy /b *.ts ..\\{}&quot;.format(path + &quot;temp//&quot;,filename))    os.system(&quot;cd {} &amp;&amp;rmdir /s/q .\\temp&quot;.format(path))if __name__ == &#39;__main__&#39;:    parse()</code></pre><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><blockquote><p> requests不支持多线程,所以在多线程的情况下会有很多分片下载不全或者干脆没下载到</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python,爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
