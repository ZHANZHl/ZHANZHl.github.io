<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程 线程</title>
      <link href="/ZHANZHl.github.io/2020/10/13/xian-dai-cao-zuo-xi-tong/"/>
      <url>/ZHANZHl.github.io/2020/10/13/xian-dai-cao-zuo-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>有两大主题</p><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><h4 id="忙等的自旋锁"><a href="#忙等的自旋锁" class="headerlink" title="忙等的自旋锁"></a>忙等的自旋锁</h4><p>形似 while(lock);</p><p>但是这一大类都需要类似cas/tsl保证操作的原子性</p><p>否则很难说不出错</p><h4 id="非忙等的信号量"><a href="#非忙等的信号量" class="headerlink" title="非忙等的信号量"></a>非忙等的信号量</h4><p>用链表保存一个未获得对应资源的队列</p><p>当对应资源释放时 检查信号量 执行对应操作</p><p>例如有1个资源</p><p>第一个线程成功申请</p><p>第二个线程发现此时资源数为0,将资源数-1,并把当前任务添加到队列中</p><p> 当第一个线程执行完毕,</p><p>将信号量+1,若此时信号量&lt;=0,从队列中唤醒一个任务</p><h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>通过编译器保证一段代码同时只有一个线程访问</p><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>读-复制-更新</p><p>保证访问到的要么是完全的旧版本,要么是完全的新版本</p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><p>调度算法有一个区别 可抢占式/不可抢占式</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>最简单的一种</p><h4 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h4><p>问题在于怎么判断一个作业的 剩余运行时间/运行时间</p><h4 id="轮转调度"><a href="#轮转调度" class="headerlink" title="轮转调度"></a>轮转调度</h4><p>每个进程运行一个时间片</p><h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>书上说 实践可行比理论上可行难太多</p><p>我的理解是 这个算法实际上减少了(运行时间长的进程)上下文切换的次数,但对于运行时间少的进程并不友好</p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>段式 面向程序员</p><p>页式 将程序分散在内存的不同位置,减少内存碎片</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>页式存储为了加快访问需要快表</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><h4 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h4><h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><p>理想中的算法,用来衡量其他算法</p><h4 id="not-recently-used"><a href="#not-recently-used" class="headerlink" title="not recently used"></a>not recently used</h4><p>翻译为 最近未使用 我觉得我听不懂</p><p>大致意思是从不是最近使用的页面中随机选择一个置换</p><h4 id="第二次机会-时钟"><a href="#第二次机会-时钟" class="headerlink" title="第二次机会/时钟"></a>第二次机会/时钟</h4><p>二者的区别是 时钟类似一个循环链表 首尾相连</p><p>每次将当前位置r标志位置0</p><p>若当前位置r为0则淘汰此页面</p><h4 id="LRU最近最少使用-NFU-老化算法"><a href="#LRU最近最少使用-NFU-老化算法" class="headerlink" title="LRU最近最少使用/NFU/老化算法"></a>LRU最近最少使用/NFU/老化算法</h4><p>LRU和老化算法的区别是 老化算法右移一位并加在最左边</p><p>LRU是每次使用一个页面时,移动到链表最前面并将次数加一</p><p>但是这样的操作太慢</p><p>近似的模拟时NFU只保存使用次数,不考虑多久未使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 进程 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp算法</title>
      <link href="/ZHANZHl.github.io/2020/09/29/kmp-suan-fa/"/>
      <url>/ZHANZHl.github.io/2020/09/29/kmp-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="kmp算法"><a href="#kmp算法" class="headerlink" title="kmp算法"></a>kmp算法</h2><blockquote><p>照着算法导论写了kmp算法</p></blockquote><pre><code class="python">def KMP(T, P):    &quot;&quot;&quot;    :param T:    :param P: 待匹配字符串    :return:    &quot;&quot;&quot;    n = len(T)    m = len(P)    k = 0    fail = get_fail(P)    for i in range(n):        while k &gt; 0 and T[i] != P[k]:            k = fail[k - 1]        if T[i] == P[k]:            k += 1        if k == m:            return True    return Falsedef get_fail(P):    n = len(P)    fail = [0] * n    k = 0    for j in range(1, n):        while k &gt; 0 and P[j] != P[k]:            k = fail[k - 1]        if P[j] == P[k]:            k = k + 1        fail[j] = k    return fail</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> kmp,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/ZHANZHl.github.io/2020/09/11/kuai-su-pai-xu/"/>
      <url>/ZHANZHl.github.io/2020/09/11/kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<!--之前其实也实现过快速排序也能理解快速排序的原理但其实实现的不是很熟练边界难以掌握希望这一次能够完全弄明白--><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>根据算法导论,实现如下</p><pre><code>def quicksort(nums, l, r):    if l &lt; r:        q = partition(nums, l, r)        quicksort(nums, l, q - 1)        quicksort(nums, q + 1, r)def partition(nums, l, r):    x = nums[r]    i = l - 1    for j in range(l, r):        if nums[j] &lt;= x:            i = i + 1            nums[i], nums[j] = nums[j], nums[i]    nums[i + 1], nums[r] = nums[r], nums[i + 1]    return i + 1</code></pre><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><h4 id="quicksort"><a href="#quicksort" class="headerlink" title="quicksort"></a>quicksort</h4><p>没什么好说的,就是普通的二分处理</p><h4 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h4><p>选定一元素,默认为最右侧元素</p><p>维护一个比选定元素小的子数组</p><p>这个子数组从0开始</p><p>每遇到比选定元素小于等于的元素使子数组扩张1个</p><p>并交换选定位置</p><p>最后交换选定元素到指定位置</p><h3 id="随机化版本"><a href="#随机化版本" class="headerlink" title="随机化版本"></a>随机化版本</h3><!--卧槽这就是大师吗?讲道理这里真的牛逼--><pre><code class="python">def random_partition(nums, l, r):    i = random.randint(l, r)    nums[i], nums[r] = nums[r], nums[i]    return partition(nums, l, r)def random_quicksort(nums, l, r):    if l &lt; r:        q = random_partition(nums, l, r)        random_quicksort(nums, l, q - 1)        random_quicksort(nums, q + 1, r)</code></pre><h3 id="迭代版本"><a href="#迭代版本" class="headerlink" title="迭代版本"></a>迭代版本</h3><pre><code class="python">def quicksort(nums, l, r):    st = [(l, r)]    while len(st) &gt; 0:        top = st.pop()        left, right = top[0], top[1]        if left &lt; right:            i = partition(nums, left, right)            st.append((left, i - 1))            st.append((i + 1, right))def partition(nums, l, r):    x = nums[r]    i = l - 1    for j in range(l, r):        if nums[j] &lt;= x:            i += 1            nums[i], nums[j] = nums[j], nums[i]    nums[i + 1], nums[r] = nums[r], nums[i + 1]    return i + 1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 快速排序,算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我印象中的http协议</title>
      <link href="/ZHANZHl.github.io/2020/09/02/wo-yin-xiang-zhong-de-http-xie-yi/"/>
      <url>/ZHANZHl.github.io/2020/09/02/wo-yin-xiang-zhong-de-http-xie-yi/</url>
      
        <content type="html"><![CDATA[<!--面试官问我 http链接能复用吗?我被这道题蒙到了,其实我看过长连接短链接的问题而且就算当时忘了也可以从下往上想所谓http链接不就是在tcp上发个报文过去服务器接收到消息再返回吗如果建立的tcp链接是一个怎么就不能复用了--><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>所以,到现在我脑海中的http协议是这样的:</p><ol><li>建立tcp连接</li><li>由客户端首先发起请求,格式固定</li><li>服务端接收到请求后,返回响应</li></ol><p>至于双方请求细节,由头部确定</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>在请求中cookie:key1=value1;</p><p>在响应中set-cookie: key:value;</p><p>在响应中的cookie只能一条一条设置,分号后面是设置这个cookie的作用于之类的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试,计算机网络,http,抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据表示</title>
      <link href="/ZHANZHl.github.io/2020/08/29/shen-ru-li-jie-ji-suan-ji-xi-tong/"/>
      <url>/ZHANZHl.github.io/2020/08/29/shen-ru-li-jie-ji-suan-ji-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>整数</p><ul><li>原码:首位符号位,其余正常的二进制</li><li>反码:首位为负值,并且需要+1,其余为正常值</li><li>补码:首位为负值,其余位为正常值</li></ul></li><li><p>浮点数</p><p>首位符号位,阶码,尾数</p><ul><li><p>阶码</p><p>我以为,阶码可以将其按位取反去理解</p><p>当全为0时特殊处理</p><p>例如 0001 可以理解为 1110 即 -6</p></li></ul><p>例: 0 0000 0001</p><p>首位为0 ,正数</p><p>阶码位置字面表示为0 E=1-(2^(4-1)-1)=-6 权重为2^(-6)=1/64</p><p>尾数为1/16</p><p>结果为 1/64*1/16</p><p>0 0001 0001</p><p>首位为0 ,正数</p><p>阶码位置字面表示为1 E=1-(2^(4-1)-1)=-6 权重为2^(-6)=1/64</p><p>尾数为17/16</p><p>结果为 1/64*17/16</p></li></ul><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>溢出都会保留低位作为新值</p><p>强制转换不改变位,只改变解释位的方法 </p><h4 id="大端小端"><a href="#大端小端" class="headerlink" title="大端小端"></a>大端小端</h4><p>对于一个整数</p><p>大端: 将高位存在低地址</p><p>小端: 将低位存在低地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据表示 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马拉车算法</title>
      <link href="/ZHANZHl.github.io/2020/08/29/ma-la-che-suan-fa/"/>
      <url>/ZHANZHl.github.io/2020/08/29/ma-la-che-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h2><blockquote><p>刷leetcode时,遇到了<a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">这道题</a></p></blockquote><p>粗一分析,发现本质上是在找这个字符串的最长回文前缀,将非前缀的转置加到前面就是结果了</p><h3 id="超时代码"><a href="#超时代码" class="headerlink" title="超时代码"></a>超时代码</h3><pre><code class="python">class Solution:    def checkP(self, s: str):        for i in range(int(len(s) / 2)):            if s[i] != s[len(s) - 1 - i]:                return False        return True    def shortestPalindrome(self, s: str) -&gt; str:        if self.checkP(s):            return s        # t = &#39;&#39;        # for i in range(len(s))[::-1]:        #     t = t + s[i]        #     p = t + s        #     if self.checkP(p):        #         return p        n=len(s)        max_num=0        for i in range(2,n):            if self.checkP(s[:i]):                max_num=max(max_num,i)        if max_num==0:            return s[1:][::-1]+s        return s[max_num:][::-1]+s</code></pre><p>每个中心遍历一遍,重复判断回文</p><p>时间复杂度O(n^2)</p><h3 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h3><pre><code class="python">class Solution:    def checkP(self, s: str):        for i in range(int(len(s) / 2)):            if s[i] != s[len(s) - 1 - i]:                return False        return True    def shortestPalindrome(self, s: str) -&gt; str:        def manacher(s1: str):            s1 = &quot;#&quot; + &quot;#&quot;.join(s1) + &quot;#&quot;            n = len(s1)            p = [0] * n            center, max_right = 0, 0            for i in range(n):                length = 0                if i &lt; max_right:                    length = min(p[center * 2 - i], max_right - i)                while i - length &gt;= 0 and i + length &lt; n and s1[i + length] == s1[i - length]:                    if length + i &gt; max_right:                        max_right = length + i                        center = i                    length += 1                p[i] = length - 1            return p        if self.checkP(s):            return s        n = len(s)        p = manacher(s)        max_num = 0        for i in range(len(p)):            if i - p[i] == 0:                max_num = max(max_num, (i + p[i])//2)        if max_num == 0:            return s[1:][::-1] + s        return s[max_num:][::-1] + s</code></pre><p>时间复杂度O(n)</p><p>参考了<a href="https://www.cxyxiaowu.com/2665.html" target="_blank" rel="noopener">这篇文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法,回文字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次pdf去水印的流程</title>
      <link href="/ZHANZHl.github.io/2020/08/20/pdf-qu-shui-yin/"/>
      <url>/ZHANZHl.github.io/2020/08/20/pdf-qu-shui-yin/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在网上找到了一份学习资料,但是上面的水印十分影响阅读,我想把水印去掉</p></blockquote><ol><li><p>首先想到的就是python有没有什么库可以操作pdf</p><blockquote><p>经过搜索发现有人用pypdf2去水印,并且贴上了代码:<a href="https://www.jianshu.com/p/f449a6e86602" target="_blank" rel="noopener">链接</a></p><p>试着运行了下这份代码,没有解决我的问题</p></blockquote></li><li><p>在查看了pypdf2官方文档,debug无果之后,尝试打印了第一页所有的格式,发现只有如下几种:</p><blockquote><p>[b’q’, b’BT’, b’Tf’, b’Tc’, b’Tm’, b’g’, b’G’, b’TJ’, b’ET’, b’Q’, b’Tr’, b’w’, b’cm’, b’re’, b’f*’, b’BDC’, b’gs’, b’Do’, b’EMC’]</p></blockquote></li><li><p>尝试依次去除一种格式,观察效果:</p><blockquote><pre><code>Tm 格式全去掉为空Tf 格式去掉为乱码g 格式全去掉出现小黑快cm 格式去掉水印出现倾斜gs 格式去掉水印变黑了Do 格式去掉水印消失了</code></pre></blockquote></li><li><p>所以说,只要把每一页的Do格式的文本替换为空,就可以达到去水印的目的</p></li><li><p>但是我觉着到目前为止的东西都太体力了,我想要一种快捷的做法</p></li><li><p>又去网上找到了一篇介绍pdf文件格式的文章, <a href="https://lazymind.me/2017/10/pdf-structure/" target="_blank" rel="noopener">链接</a></p></li><li><p>在程序中打印了格式为Do的数据,输出如下</p><blockquote><p>[‘/KSPX1’]</p></blockquote></li><li><p>用文本编辑器打开pdf文件并搜索,得到这样的内容</p><p><img src="img.jpg" alt=""></p></li><li><p>将<code>&lt;&lt;/KSPX1 5548 0 R &gt;&gt;</code>删除可以删除一页的水印</p></li><li><p>而由前面的文章可以知道,这个是一个间接引用,将关键字改为5548 0 obj可以搜索到</p><p><img src="img2.jpg" alt=""></p></li><li><p>将这一段删掉即可去除整个pdf的水印</p></li></ol><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ol><li>如果一页的水印只有一个的话,可以尝试计算出对应格式出现的次数,优先删除出现次数为1的格式</li><li>到现在也不明白所谓的格式是什么</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> pdf,小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker镜像加速配置</title>
      <link href="/ZHANZHl.github.io/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/"/>
      <url>/ZHANZHl.github.io/2020/06/03/docker-jing-xiang-jia-su-pei-zhi/</url>
      
        <content type="html"><![CDATA[<pre><code class="json">  &quot;registry-mirrors&quot;: [    &quot;https://hub-mirror.c.163.com/&quot;,    &quot;https://registry.docker-cn.com&quot;,    &quot;https://docker.mirrors.ustc.edu.cn&quot;,    &quot;https://reg-mirror.qiniu.com&quot;,    &quot;https://mirror.ccs.tencentyun.com&quot;  ],</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> docker,环境配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python多线程</title>
      <link href="/ZHANZHl.github.io/2020/05/25/python-duo-xian-cheng/"/>
      <url>/ZHANZHl.github.io/2020/05/25/python-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>每次用到python多线程,都是看了就忘</p></blockquote><h3 id="threading"><a href="#threading" class="headerlink" title="threading"></a>threading</h3><p>用法:<code>threading.Thread(target=函数名)</code>创建线程,<code>start</code>开始执行,<code>join</code>等待完成</p><p>示例:</p><pre><code class="python">import threadingreader_count = 0write_count = 0reader_amount = 0write_amount = 0def reader():    global reader_count, write_count, reader_amount, write_amount    while reader_amount &gt; 0:        if reader_count &gt; 0 or write_count == 0:            reader_count += 1            print(&#39;read&#39;)            reader_amount -= 1            reader_count -= 1        else:            print(&quot;can&#39;t read&quot;)def writer():    global reader_count, write_count, reader_amount, write_amount    while write_amount &gt; 0:        if reader_count &gt; 0 or write_count &gt; 0:            print(&quot;can&#39;t write&quot;)        else:            write_count += 1            print(&#39;write&#39;)            write_amount -= 1            write_count -= 1if __name__ == &#39;__main__&#39;:    reader_amount = int(input(&#39;读次数:&#39;))    write_amount = int(input(&#39;写次数:&#39;))    read = threading.Thread(target=reader)    write = threading.Thread(target=writer)    write.start()    read.start()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手撕bp神经网络</title>
      <link href="/ZHANZHl.github.io/2020/05/24/zhi-neng-ji-suan/"/>
      <url>/ZHANZHl.github.io/2020/05/24/zhi-neng-ji-suan/</url>
      
        <content type="html"><![CDATA[<p>智能计算的作业,按照公式实现</p><pre><code class="python">import mathimport random# node 三维数组# 第一维表示层# 第二维表示节点# 第三维分别表示输出,到下一层节点的权值,最后一个表示sitadef BP_test(node):    print(&#39;输入数据&#39;)    num1 = int(input())    num2 = int(input())    node[0][0][0] = num1    node[0][1][0] = num2    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj    print(node[-1][0][0])def BP_once(node, y_train, s=0.6):    # 前向计算每个神经元的输出加权和sj和输出    for layer_count in range(1, len(node)):  # 从第二层开始,遍历每一层        for node_index in range(len(node[layer_count])):  # 对于当前层的每一个节点            sj = 0            for i in range(len(node[layer_count - 1])):  # 遍历上一层的每一个节点,得出sj                sj += node[layer_count - 1][i][node_index + 1] * node[layer_count - 1][i][0]            length = len(node[layer_count][node_index])            sj += node[layer_count][node_index][length - 1]            node[layer_count][node_index][0] = 1 / (1 + math.exp(-sj))  # 这个点就是oj            # print(node[layer_count][node_index][0])    y = []    t = y_train    for layer_count in range(1, len(node))[::-1]:        y = t        t = []        for node_index in range(len(node[layer_count])):            oj = node[layer_count][node_index][0]            ej = oj * (1 - oj)            if layer_count == len(node) - 1:                ej *= (y_train[node_index] - oj)                t.append(ej)            else:                we = 0                for i in range(len(node[layer_count + 1])):                    we += y[i] * node[layer_count][node_index][i + 1]                ej *= we            # 先更新sita            node[layer_count][node_index][-1] += s * ej            for i in range(len(node[layer_count - 1])):  # 更新上一层节点的权重                node[layer_count - 1][i][node_index + 1] += s * node[layer_count - 1][i][0] * ej    passdef BP_main(x_train, y_train, s=0.6, t=5000):    random.seed(1)    node = []    node.append([[1, 0.2, -0.3], [0, 0.4, 0.1]])    node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    node.append([[1, 0.1]])    for i in range(len(node)):        for j in range(len(node[i])):            for k in range(len(node[i][j])):                node[i][j][k] = random.random()    train_count = 0    for k in range(t):        for i in range(len(x_train)):  # 选中第几组训练数据            y = []            y.append(y_train[i])            for j in range(len(x_train[i])):                node[0][j][0] = x_train[i][j]            BP_once(node, y, s)    return nodeif __name__ == &#39;__main__&#39;:    # node = []    # node.append([[1, 0.2, -0.3], [0, 0.4, 0.1], [1, -0.5, 0.2]])    # node.append([[1, -0.3, -0.4], [0, -0.2, 0.2]])    # node.append([[1, 0.1]])    # BP_once(node, [1])    node = BP_main([[0, 0], [0, 1], [1, 0], [1, 1]], [0, 1, 1, 0])    print(&quot;训练结束&quot;)    while True:        BP_test(node)</code></pre><p><code>BP_once:</code>训练一次,可设置学习率</p><p><code>BP_main:</code>反复调用BP_once达到训练多次的目的,并且这里也定义了层数,节点数,和权值的初始化,这个函数有两个参数,第一个是一个二维数组,第一维表示不同的训练数据,第二维表示训练数据的不同值,第二个参数是包含不同训练数据的结果的数组</p>]]></content>
      
      
      
        <tags>
            
            <tag> 人工智能 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端</title>
      <link href="/ZHANZHl.github.io/2020/03/19/qian-duan/"/>
      <url>/ZHANZHl.github.io/2020/03/19/qian-duan/</url>
      
        <content type="html"><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="js跳转到不同的url"><a href="#js跳转到不同的url" class="headerlink" title="js跳转到不同的url"></a>js跳转到不同的url</h2><ol><li><p>设置不同的button</p></li><li><p>为每个button设置onclick事件</p></li><li><p>事件内容如下:</p><pre><code class="javascript">function 方法名() {     document.你的表单名.action=&quot;要跳转到的url&quot;     document.你的表单名.submit()}</code></pre></li></ol><h2 id="五子棋"><a href="#五子棋" class="headerlink" title="五子棋"></a>五子棋</h2><blockquote><p>大二时通过一本书学会了画五子棋的棋盘和棋子,于是写了个AI</p></blockquote><p><a href="https://zhanzhl.github.io/gobang/">效果演示</a></p><pre><code>var canvas =document.getElementById(&quot;canvas&quot;)        var ctx =canvas.getContext(&quot;2d&quot;)        var isblack=true        var arr=new Array()        var wei=new Array()        for(var i=0;i&lt;20;i++)//定义棋子局势        {            arr[i]=new Array();            for(var j=0;j&lt;20;j++)            {                arr[i][j]=0;            }        }        for(i=0;i&lt;20;i++)//设置棋子权重        {            wei[i]=new Array();            for(j=0;j&lt;20;j++)            {                wei[i][j]=20-Math.abs(i+j-20)            }        }        ctx.strokeStyle=&quot;#009688&quot;        ctx.beginPath();        for(i=0;i&lt;19;i++)        {            ctx.moveTo(10+i*20,10)            ctx.lineTo(10+i*20,370)            ctx.moveTo(10,10+20*i)            ctx.lineTo(370,10+i*20)        }        ctx.stroke()        $(&quot;#canvas&quot;).click(function(e){            if(!isblack)            {                alert(&quot;请稍后&quot;)                return            }            console.log(e.offsetX+&quot;,&quot;+e.offsetY)            var thisx=Math.round((e.offsetX-10)/20)            var thisy=Math.round((e.offsetY-10)/20)            if(luozi(thisx,thisy))                myAI()        })        function luozi(thisx,thisy)        {            if(arr[thisx][thisy]==0)            {                ctx.beginPath()                if(isblack)                {                    ctx.fillStyle=&quot;black&quot;                    arr[thisx][thisy]=1                }                else                {                    ctx.fillStyle=&quot;white&quot;                    arr[thisx][thisy]=2                }                ctx.arc(thisx*20+10,thisy*20+10,10,0,Math.PI*2,false)                ctx.fill()                ctx.stroke()                //(0,1)竖直方向胜利                //(1,0)水平方向胜利                //(1,1)从左上到右下                //(1,-1)从左下到右上                testVictory(0,1,thisx,thisy)                testVictory(1,0,thisx,thisy)                testVictory(1,1,thisx,thisy)                testVictory(1,-1,thisx,thisy)                updatewei(thisx,thisy)                isblack=!isblack                return true;            }            return false        }        function testVictory(x,y,newx,newy)        {            var max=1            var tx=newx            var ty=newy            var flag=arr[newx][newy]            while(arr[tx+x][ty+y]==flag)            {                tx=tx+x                ty=ty+y                max++            }            while(arr[newx-x][newy-y]==flag)            {                newx=newx-x                newy=newy-y                max++            }            if(max&gt;4)            {                flag==1?alert(&quot;黑方胜&quot;):alert(&quot;白方胜&quot;)                location.reload()            }        }        function updatewei(thisx,thisy)        {            var i=-4;            var j=-4;            if(thisx+i&lt;=0)                i=1-thisx;            if(thisy+j&lt;=0)                j=1-thisy;                var str=&quot;&quot;;            for(;i&lt;5;i++)            {                for(var j=-4;j&lt;5;j++)                {                    if(arr[thisx+i][thisy+j]==0)                    wei[thisx+i][thisy+j]=testWeight(thisx+i,thisy+j)                    str+=wei[thisx+i][thisy+j]+&quot;(&quot;+(thisx+i)+&quot;,&quot;+(thisy+j)+&quot;)&quot;+&quot;\t&quot;;                }                str+=&quot;\n&quot;            }            console.log(str);        }        function testWeight(thisx,thisy)        {            var weight=20-Math.abs(thisx+thisy-20);            weight+=tance(thisx,thisy,0,1,true)            weight+=tance(thisx,thisy,1,1,true)            weight+=tance(thisx,thisy,1,-1,true)            weight+=tance(thisx,thisy,1,0,true)            weight+=tance(thisx,thisy,0,1,false)            weight+=tance(thisx,thisy,1,1,false)            weight+=tance(thisx,thisy,1,-1,false)            weight+=tance(thisx,thisy,1,0,false)            return weight        }        function tance(newx,newy,x,y,black)        {            var count=0;            var tx=newx;            var ty=newy;            var flag=0;//当前棋子颜色            black?flag=1:flag=2;            var max=5;//探测半径            var mlen=0;//最大连续长度            var iscon=true;//是否连续            while(--max&amp;&amp;tx+x&gt;0&amp;&amp;ty+y&gt;0&amp;&amp;tx+x&lt;20&amp;&amp;ty+y&lt;20)            {                tx=tx+x;                ty=ty+y;                if(arr[tx][ty]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[tx][ty]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            max=5;            while(--max&amp;&amp;newx-x&gt;0&amp;&amp;newy-y&gt;0&amp;&amp;newx-x&lt;20&amp;&amp;newy-y&lt;20)            {                newx=newx-x;                newy=newy-y;                if(arr[newx][newy]==flag)//如果这个点的颜色等于当前颜色                {                    mlen++;                    count=count+max*10;                }                else                {                    if(arr[newx][newy]==0)                        continue;                    else                    {                        mlen--;                        break;                    }                }            }            if(mlen&gt;=4)                count=count*1000;            else if(mlen&gt;=3)                count=count*100;            else if(mlen&gt;=2)                count=count*10;            else                count=count;            if(count&lt;0)                count=0;            if(flag==2&amp;&amp;mlen==4)                count*=10;            return count        }        function myAI()//把上面那个写好了,这个函数只是一个遍历的事了        {            var x=1;            var y=1;            var weight=0            for(var i=0;i&lt;20;i++)            {                for(var j=0;j&lt;20;j++)                {                    if(weight&lt;wei[i][j]&amp;&amp;arr[i][j]==0)                    {                        weight=wei[i][j]                        x=i                        y=j                    }                }            }            console.log(&quot;我在&quot;+x+&quot; &quot;+y+&quot;下白子,权重是&quot;+wei[x][y]);            luozi(x,y);        }</code></pre><h2 id="油猴百度网盘自动填写提取码脚本"><a href="#油猴百度网盘自动填写提取码脚本" class="headerlink" title="油猴百度网盘自动填写提取码脚本"></a>油猴百度网盘自动填写提取码脚本</h2><pre><code class="javascript">// ==UserScript==// @name         百度网盘自动填写提取码// @namespace    http://tampermonkey.net/// @version      0.2// @description  try to take over the world!// @author       zhanzhi// @match        https://pan.baidu.com/*// @grant        none// ==/UserScript==(function() {    &#39;use strict&#39;;var body=document.getElementsByTagName(&#39;body&#39;)[0]var reg=/https?:\/\/pan.baidu.com\/s\/.{23}.*?提取码.*?([0-9a-zA-Z]{4})/svar link_reg=/^https?:\/\/pan.baidu.com\/s\/.(.{22})/var key_reg=/[0-9a-zA-Z]{4}$/var links_and_keys=body.innerHTML.match(reg)var links=[]var keys=[]if(location.href.match(/^https?:\/\/pan.baidu.com/)!==null){    var key=location.href.split(&#39;#&#39;)[1]    var key_input=document.getElementsByTagName(&#39;input&#39;)[0]    if(typeof key ===&quot;string&quot;)    {        key_input.value=key        var but=document.getElementsByClassName(&quot;g-button g-button-blue-large&quot;)[0]        but.click()    }}else{    var vm=body.innerHTML    links.push(links_and_keys[0].match(link_reg)[0])    keys.push(links_and_keys[1].match(key_reg)[0])    var surl=links_and_keys[0].match(link_reg)[1]    var url=&#39;https://pan.baidu.com/share/init?surl=&#39;+surl    vm=vm.replace(links_and_keys[0].match(link_reg)[0],url+&#39;#&#39;+links_and_keys[0].match(key_reg)[0])    body.innerHTML=vm}})();</code></pre><blockquote><p>经观察,虽然百度盘的分享链接会重定向</p><p>不过重定向的url都是有规律的</p><p>如分享链接为<a href="https://pan.baidu.com/s/1.{22}" target="_blank" rel="noopener">https://pan.baidu.com/s/1.{22}</a></p><p>那么填写提取码的链接就是<a href="https://pan.baidu.com/share/init?surl=加上上面.{22}匹配到的内容" target="_blank" rel="noopener">https://pan.baidu.com/share/init?surl=加上上面.{22}匹配到的内容</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用python爬取m3u8视频</title>
      <link href="/ZHANZHl.github.io/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/"/>
      <url>/ZHANZHl.github.io/2020/03/14/yong-python-pa-qu-m3u8-shi-pin/</url>
      
        <content type="html"><![CDATA[<h4 id="用python爬取m3u8视频"><a href="#用python爬取m3u8视频" class="headerlink" title="用python爬取m3u8视频"></a>用python爬取m3u8视频</h4><h4 id="m3u8格式"><a href="#m3u8格式" class="headerlink" title="m3u8格式"></a>m3u8格式</h4><p>m3u8是纯文本文档,里面包含了每个视频段的链接</p><p>合起来就是一个完整的视频,如下所示</p><pre><code>#EXTM3U#EXT-X-VERSION:3#EXT-X-TARGETDURATION:7#EXT-X-MEDIA-SEQUENCE:0#EXTINF:4.712100,4ddf19cc057000000.ts#EXTINF:4.170000,4ddf19cc057000001.ts#EXTINF:4.170000,4ddf19cc057000002.ts</code></pre><p>应注意到<code>4ddf19cc057000000.ts</code>是第一个视频的链接,但是无法直接打开</p><p>因为这个链接是不完整的,需要在这个链接前加上完整的路径才是完整的链接</p><p>如:</p><p>你找到了一个m3u8文件,他的链接是<a href="http://localhost/path/m3u8/index.m3u8" target="_blank" rel="noopener">http://localhost/path/m3u8/index.m3u8</a></p><p>里面第一段视频链接是1.ts</p><p>那么这段视频的完整地址是<a href="http://localhost/path/m3u8/1.ts" target="_blank" rel="noopener">http://localhost/path/m3u8/1.ts</a></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>import requestsimport osfrom concurrent.futures import ThreadPoolExecutor, ALL_COMPLETEDm3u8_url = &#39;m3u8的链接&#39;  # m3u8的链接filename = &#39;22&#39;  # 下载后保存的名字max_worker = 8  # 线程数proxy = {&#39;http&#39;: &#39;http://127.0.0.1:1080&#39;, &#39;https&#39;: &#39;http://127.0.0.1:1080&#39;}  # 代理设置path = &quot;下载到哪个路径&quot;  # 下载到哪个路径def download_file(url, filename):    r = requests.get(url, proxies=proxy)    while r.status_code != 200:        r = requests.get(url, proxies=proxy)        print(filename,&#39;请求超时&#39;)    with open(filename, &quot;wb+&quot;) as f:        f.write(r.content)def parse():    pool = ThreadPoolExecutor(max_worker)    r = requests.get(m3u8_url, timeout=5, proxies=proxy)    base_url = os.path.dirname(m3u8_url)    temp = path + &quot;temp&quot; + os.path.sep    if not os.path.exists(temp):        os.makedirs(temp)    i = 0    for line in r.text.split(&#39;\n&#39;):        if line.find(&quot;.ts&quot;) != -1:            if not line.startswith(&quot;http&quot;):                line = base_url + &#39;/&#39; + line            pool.submit(download_file, line, temp + str(i).zfill(8) + &quot;.ts&quot;)            i = i + 1    pool.shutdown(wait=True)    os.system(&quot;cd {} &amp;&amp;copy /b *.ts ..\\{}&quot;.format(path + &quot;temp//&quot;,filename))    os.system(&quot;cd {} &amp;&amp;rmdir /s/q .\\temp&quot;.format(path))if __name__ == &#39;__main__&#39;:    parse()</code></pre><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><blockquote><p> requests不支持多线程,所以在多线程的情况下会有很多分片下载不全或者干脆没下载到</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python,爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
